/* $Id: wfa_cs.c,v 1.86 2011-01-27 19:29:02 $ */
/****************************************************************************
 *  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
 *
 *
 *  LICENSE
 *
 *  License is granted only to Wi-Fi Alliance members and designated
 *  contractors ($B!H(BAuthorized Licensees$B!I(B)..AN  Authorized Licensees are granted
 *  the non-exclusive, worldwide, limited right to use, copy, import, export
 *  and distribute this software:
 *  (i) solely for noncommercial applications and solely for testing Wi-Fi
 *  equipment; and
 *  (ii) solely for the purpose of embedding the software into Authorized
 *  Licensee$B!G(Bs proprietary equipment and software products for distribution to
 *  its customers under a license with at least the same restrictions as
 *  contained in this License, including, without limitation, the disclaimer of
 *  warranty and limitation of liability, below..AN  The distribution rights
 *  granted in clause
 *  (ii), above, include distribution to third party companies who will
 *  redistribute the Authorized Licensee$B!G(Bs product to their customers with or
 *  without such third party$B!G(Bs private label. Other than expressly granted
 *  herein, this License is not transferable or sublicensable, and it does not
 *  extend to and may not be used with non-Wi-Fi applications..AN  Wi-Fi Alliance
 *  reserves all rights not expressly granted herein..AN
 *.AN
 *  Except as specifically set forth above, commercial derivative works of
 *  this software or applications that use the Wi-Fi scripts generated by this
 *  software are NOT AUTHORIZED without specific prior written permission from
 *  Wi-Fi Alliance.
 *.AN
 *  Non-Commercial derivative works of this software for internal use are
 *  authorized and are limited by the same restrictions; provided, however,
 *  that the Authorized Licensee shall provide Wi-Fi Alliance with a copy of
 *  such derivative works under a perpetual, payment-free license to use,
 *  modify, and distribute such derivative works for purposes of testing Wi-Fi
 *  equipment.
 *.AN
 *  Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 *  or promote products that are derived from or that use this software without
 *  specific prior written permission from Wi-Fi Alliance.
 *
 *  THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A.AN PARTICULAR PURPOSE,
 *  ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ******************************************************************************
 */

/*
 *   File: wfa_cs.c -- configuration and setup
 *   This file contains all implementation for the dut setup and control
 *   functions, such as network interfaces, ip address and wireless specific
 *   setup with its supplicant.
 *
 *   The current implementation is to show how these functions
 *   should be defined in order to support the Agent Control/Test Manager
 *   control commands. To simplify the current work and avoid any GPL licenses,
 *   the functions mostly invoke shell commands by calling linux system call,
 *   system("<commands>").
 *
 *   It depends on the differnt device and platform, vendors can choice their
 *   own ways to interact its systems, supplicants and process these commands
 *   such as using the native APIs.
 *
 *   Revision History:
 *        2006/03/10  -- initially created by qhu
 *        2006/06/01  -- BETA Release by qhu
 *        2006/06/13  -- 00.02 Release by qhu
 *        2006/06/30  -- 00.10 Release by qhu
 *        2006/07/10  -- 01.00 Release by qhu
 *        2006/09/01  -- 01.05 Release by qhu
 *        2006/10/26  -- 01.06 Released by qhu
 *                       replace hardcoded buf size with macro
 *        2006/12/02  -- bugs: 1. fixes incorrect order of getipconfig.sh
 *                                input parameters reported by p.schwann
 *                             2. will add a new network for wap_cli command
 *                                in case the network id 0 not present,
 *                                recommended by c.benson
 *                                the solution is to reimplement with calling
 *                                native C API
 *        2007/01/11  -- 01.10 released by qhu
 *        2007/02/15  -- WMM Extension Beta released by qhu, mkaroshi
 *        2007/03/18  -- add file close statements
 *        2007/03/21  -- rename the file to avoid the confusion.
 *        2007/03/30  -- 01.40 WPA2 and Official WMM Beta Release by qhu
 *        2007/04/20  -- 02.00 WPA2 and Official WMM Release by qhu
 *        2007/08/15 --  02.10 WMM-Power Save release by qhu
 *        2007/10/10 --  02.20 Voice SOHO beta -- qhu
 *        2007/11/07 --  02.30 Voice HSO -- qhu
 *        2007/12/10 --  02.32 Add a function to upload test results.
 *        2008/01/03 --  02.34 Support the result upload command.
 *        2008/03/12 --  02.41 Bug #16, incorrect file descriptor used. Change
 *                       the "tmpfile" to "tmpfd" and a few places. Make a macro
 *                       WFA_STAUT_IF in file "inc/wfa_cs.h" for WLAN interface
 *                       name in the function "wfaDeviceListIF()
 *
 *                       Not A Bug. Put back to the function from
 *                       wfaSetEncryption1() to wfaSetEncryption() for
 *                       supporting WEP. Porting could select which should be
 *                       used according to WEP support or not.
 *
 *
 */
#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <linux/types.h>
#include <linux/socket.h>
#include <poll.h>

#include <sys/ioctl.h>
#include <net/if.h>
#include <linux/ethtool.h>
#include <linux/sockios.h>

#include <pthread.h>

#include "wfa_portall.h"
#include "wfa_debug.h"
#include "wfa_ver.h"
#include "wfa_main.h"
#include "wfa_types.h"
#include "wfa_ca.h"
#include "wfa_tlv.h"
#include "wfa_sock.h"
#include "wfa_tg.h"
#include "wfa_cmds.h"
#include "wfa_rsp.h"
#include "wfa_utils.h"
#ifdef WFA_WMM_PS_EXT
#include "wfa_wmmps.h"
#endif

#include "p2p_app.h"
#include "p2plib_api.h"
#include "p2pwl.h"
#include "BcmP2PAPI.h"
#include "BcmP2PDbg.h"
#include "wlioctl.h"
#include "p2papp_wfd.h"

#define EXIT_ON_FAILURE		0	/* for test/debug */

/* Scripts */
#if defined(TARGETENV_android)
   #define GET_IP_CONFIG_SCRIPT   "/data/sbin/getipconfig.sh"
   #define GET_PID_SCRIPT         "/data/sbin/getpid.sh"
   #define GET_PSTATS_SCRIPT      "/data/sbin/getpstats.sh"
   #define STOPING_SCRIPT         "/data/sbin/stoping.sh"
   #define UPDATE_PID_SCRIPT      "/data/sbin/updatepid.sh"
   #define WFA_PING_SCRIPT        "/data/sbin/wfaping.sh"
#else
   #define GET_IP_CONFIG_SCRIPT   "/usr/local/sbin/getipconfig.sh"
   #define GET_PID_SCRIPT         "/usr/local/sbin/getpid.sh"
   #define GET_PSTATS_SCRIPT      "/usr/local/sbin/getpstats.sh"
   #define STOPING_SCRIPT         "/usr/local/sbin/stoping.sh"
   #define UPDATE_PID_SCRIPT      "/usr/local/sbin/updatepid.sh"
   #define WFA_PING_SCRIPT        "/usr/local/sbin/wfaping.sh"
#endif


#if defined(TARGETENV_android)
   #define WL_BIN_PREFIX_STRING     "/system/bin"
   #define NET_FILE_CREATION_PATH   "/data/local"
   #define IFCONFIG                 "ifconfig"
   #define ROUTE                    "route"
#elif defined(TARGETENV_BCMSTB)
   #define WL_BIN_PREFIX_STRING     "."
   #define NET_FILE_CREATION_PATH   "/tmp"
   #define IFCONFIG                 "/bin/ifconfig"
   #define ROUTE                    "/bin/route"
#else
   #define WL_BIN_PREFIX_STRING     "."
   #define NET_FILE_CREATION_PATH   "/tmp"
   #define IFCONFIG                 "/sbin/ifconfig"
   #define ROUTE                    "/sbin/route"
   #define IFCONFIG_ALT             "/usr/sbin/ifconfig"
#endif
   #define IFCONFIG_NOPATH          "ifconfig"

/* DHCP client. */
#if defined(USE_UCLIBC)
   #define DHCP_CLIENT_TYPE_DHCPCD   0
   #define DHCP_CLIENT_TYPE_DHCLIENT 0
#elif defined(TARGETENV_android)
   #define DHCP_CLIENT_TYPE_DHCPCD   1
   #define DHCPCD                    "dhcpcd"
#elif defined(TARGETENV_BCMSTB)
   #define DHCP_CLIENT_TYPE_DHCPCD   1
   #define DHCPCD                    "/bin/dhcpcd"
#else
   #define DHCP_CLIENT_TYPE_DHCLIENT 1
   #define DHCLIENT                  "/sbin/dhclient"
#endif

/* DNS */
#if defined(TARGETENV_android)
   #define DNS_SUPPORTED 0
#elif defined(TARGETENV_BCMSTB)
   #define DNS_SUPPORTED 1
#else
   #define DNS_SUPPORTED 1
#endif



#undef DPRINT_ERR
#define DPRINT_ERR(fd,...)     do { \
                                  fprintf(WFA_ERR, "File %s, Line %ld: ", \
                                          __FILE__, (long)__LINE__); \
                                  fprintf(fd, __VA_ARGS__); \
                                  p2papi_log(BCMP2P_LOG_MED, 1, __VA_ARGS__); \
                               } while (0)

#undef DPRINT_INFO
#define DPRINT_INFO(fd,...)     do { \
                                   if(wfa_defined_debug & WFA_DEBUG_INFO) \
                                      fprintf(fd, __VA_ARGS__); \
                                      p2papi_log(BCMP2P_LOG_MED, 1, __VA_ARGS__); \
                                } while (0)

#undef DPRINT_WARNING
#define DPRINT_WARNING(fd,...)     do { \
                                   if(wfa_defined_debug & WFA_DEBUG_WARNING) \
                                      fprintf(fd, __VA_ARGS__); \
                                      p2papi_log(BCMP2P_LOG_MED, 1, __VA_ARGS__); \
                                } while (0)






#ifdef TARGETENV_android
   #define CERTIFICATES_PATH    "/system/bin/wpa_supplicant"
#else
   #define CERTIFICATES_PATH    "/etc/wpa_supplicant"
#endif

#define DISCOVER_PEER_TIMEOUT_SEC       	60
#define PROVISION_DISCOVERY_TIMEOUT_MSEC	10 * 1000
#define CONNECTION_CREATE_TIMEOUT_MSEC  	60 * 1000
#define DISCOVERY_DISABLE_MSEC				10 * 1000

static char P2P_GO_SSID_CHARSET[] =
               "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz";
#define P2P_GO_SSID_CHARSET_SIZE (sizeof(P2P_GO_SSID_CHARSET) - 1)
#define GEN_RAND_P2P_SSID_CHAR \
           P2P_GO_SSID_CHARSET[random() % P2P_GO_SSID_CHARSET_SIZE]

#define P2P_VNDR_IE_PARAMS "0x30 9 50:6f:9a 090202000000"

/* Some device may only support UDP ECHO, activate this line */
//#define WFA_PING_UDP_ECHO_ONLY 1

extern unsigned short wfa_defined_debug;
int wfaExecuteCLI(char *CLI);

/* Since the two definitions are used all over the CA function */
char gCmdStr[WFA_CMD_STR_SZ];
dutCmdResponse_t gGenericResp;
int wfaTGSetPrio(int sockfd, int tgClass);
void create_apts_msg(int msg, unsigned int txbuf[],int id);

extern char e2eResults[];
//extern char *e2eResults;
FILE *e2efp = NULL;
int chk_ret_status()
{
    char *ret = getenv(WFA_RET_ENV);

    if(*ret == '1')
       return TRUE;
    else
       return FALSE;
}

/* NoA parameters saved and applied if/when GO created */
struct {
   BCMP2P_BOOL isEnabled;
   BCMP2P_UINT32 duration;
   BCMP2P_UINT32 interval;
   BCMP2P_UINT32 count;
} gNoa;


static BCMP2P_WPS_CONFIG_METHODS g_config_method;
#if defined(BRCM_P2P_EXTSEC)
static char g_passPhrase[WFA_PSK_PP_LEN];
#endif


typedef enum P2P_MODE
{
   P2P_MODE_DISABLE,
   P2P_MODE_IDLE,
   P2P_MODE_LISTEN,
   P2P_MODE_DISCOVER
} P2P_MODE;

static P2P_MODE g_p2p_mode = P2P_MODE_IDLE;

static BOOL g_reset_11n_settings = FALSE;
static int g_p2p_ie_added_to_primary_intf = 0;

static char g_bogus_arp_ipaddress[WFA_IP_ADDR_STR_LEN] = {'\0'};

static int wfa_snprintf(char *str, size_t size, const char *format, ...);
static int wfaStaSetP2pMode(P2P_MODE mode);
static int wfaStaGetP2pMode(void);

typedef struct dut_commands_params {
	char cmdName[32];  
	char intf[WFA_IF_NAME_LEN];
	char parameter[128];
	
	/* The xx_flag indicates whether this is to set-1 or get-0 a parameter */

	int sess_avl_flag;
	char sess_avl[8];

	int rtsp_port_flag;
	int rtsp_port;

	int hdcp_flag;
	int hdcp;

	int dev_type_flag;
	char dev_type[8];

	int connection_type_flag;
	int connection_type;

    /* String format xx:xx:xx:xx:xx:xx */
    char alt_mac[32];
	char peer_p2p_mac[32];

} dutCmdParams_t;

static dutCmdParams_t gDutParams;
static int  sw_reset = 0;

/*
 * agtCmdProcGetVersion(): response "ca_get_version" command to controller
 *  input:  cmd --- not used
 *          valLen -- not used
 *  output: parms -- a buffer to store the version info response.
 */
int agtCmdProcGetVersion(int len, BYTE *parms, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *getverResp = &gGenericResp;
    caStaGetVer_t *get_ver = (caStaGetVer_t *)parms;

    DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

    /* TestInfo is an optional parameter to give some debug information to the
     * STA about what test is getting performed. Use this string to generate
     * the output log filename.
     */
    if (get_ver->testinfo_flag)
    {
       p2papp_set_log_file(get_ver->testinfo);
    }


    getverResp->status = STATUS_COMPLETE;
    wSTRNCPY(getverResp->cmdru.version, WFA_SYSTEM_VER, sizeof(getverResp->cmdru.version));

    wfaEncodeTLV(WFA_GET_VERSION_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)getverResp, respBuf);

    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

    return TRUE;
}

/*
 * wfaStaAssociate():
 *    The function is to force the station wireless I/F to re/associate
 *    with the AP.
 */


int wfaStaAssociate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   BCMP2P_STATUS status = BCMP2P_SUCCESS;
   dutCmdResponse_t *resp = &gGenericResp;
   dutCommand_t     *cmd  = (dutCommand_t *)caCmdBuf;
   char buf[128];
   int p2p_mode;

   // WPS stations only
   caStaAssociate_t *assoc_wps = (caStaAssociate_t *)&(cmd->cmdsu.wps_assoc);
   int use_wps = assoc_wps->wps;


   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   // WPS stations
   DPRINT_INFO(WFA_OUT, "The WPS option is : %d \n", use_wps);

   /* Suspend P2P device discovery to prevent generating large amounts of
    * harmless but distracting discovery scan ioctl errors.
    */
   p2papp_suspend_discovery();

   p2p_mode = wfaStaGetP2pMode();
   if (p2p_mode != P2P_MODE_DISABLE)
   {
      g_p2p_ie_added_to_primary_intf = 1;
      /* Add the P2P IE to probe requests and association requests. This is
       * required when associating to a P2P managed AP. */
      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl -i %s add_ie %s", WL_BIN_PREFIX_STRING, cmd->intf, P2P_VNDR_IE_PARAMS);
      DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      system(gCmdStr);
   }


   if (use_wps)
   {
      if (g_config_method == BCMP2P_WPS_PUSHBUTTON)
      {
         wfa_snprintf(buf, sizeof(buf), "%s/wpsenr -if %s -sec 1 -ssid %s -pb",
                      WL_BIN_PREFIX_STRING, cmd->intf, cmd->cmdsu.ssid);
      }
      else
      {
         wfa_snprintf(buf, sizeof(buf), "%s/wpsenr -if %s -sec 1 -ssid %s -pin %s",
                      WL_BIN_PREFIX_STRING, cmd->intf, cmd->cmdsu.ssid, BCMP2PGetWPSPin(p2papp_get_hdl()));
      }

      DPRINT_INFO(WFA_OUT, "Starting wpsenr ....\n");
      DPRINT_INFO(WFA_OUT, "%s\n", buf);
      if (system(buf) != 0)
      {
         DPRINT_ERR(WFA_ERR, "%s: wpsenr failed!\n", __FUNCTION__);
         status = BCMP2P_ERROR;
         goto exit;
      }

      /* Bring up the interface. */
      if (!access(IFCONFIG, F_OK))
	      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s %s up", IFCONFIG, cmd->intf);
#ifdef IFCONFIG_ALT
      else if (!access(IFCONFIG_ALT, F_OK))
	      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s %s up", IFCONFIG_ALT, cmd->intf);
#endif
      else
	      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s %s up", IFCONFIG_NOPATH, cmd->intf);

      DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      system(gCmdStr);
      system("sleep 1");

      /* Start the DHCP client. */
#if DHCP_CLIENT_TYPE_DHCPCD
      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s %s", DHCPCD, cmd->intf);
#elif DHCP_CLIENT_TYPE_DHCLIENT
      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s %s &", DHCLIENT, cmd->intf);
#endif
      DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      system(gCmdStr);
   }
   else
   {
#if defined(BRCM_P2P_EXTSEC)
	  /* use cxapi for external security */
	  /* cnClient MUST be compiled with CX_NO_DISCONNECT=1 */
      wfa_snprintf(buf, sizeof(buf), "%s/cnClient -A %s -ssid %s -wpa2-psk %s -aes",
         WL_BIN_PREFIX_STRING, cmd->intf, cmd->cmdsu.ssid, g_passPhrase);
      DPRINT_INFO(WFA_OUT, "Starting cnClient ....\n");
      DPRINT_INFO(WFA_OUT, "%s\n", buf);
      if (system(buf) != 0)
      {
         DPRINT_ERR(WFA_ERR, "%s: cnClient failed!\n", __FUNCTION__);
         status = BCMP2P_ERROR;
         goto exit;
      }
#else
      FILE *tmpfile = NULL;
      int sup_status;
      int timeout_sec;
      int join_attempts;
      const int max_join_timeout_sec = 6;
      const int max_legacy_join_attempts = 10;
      int b_joined;

      b_joined = 0;
      for (join_attempts = 0; join_attempts < max_legacy_join_attempts; join_attempts++)
      {
         wfa_snprintf(buf, sizeof(buf), "%s/wl -i %s join %s imode bss amode wpa2psk", WL_BIN_PREFIX_STRING, cmd->intf, cmd->cmdsu.ssid);
         DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, buf);
         system(buf);

         /* Wait for scan to complete and join attempt. */
         system("sleep 3");

         /* Check if STA is associated. */
         for (timeout_sec = 0; timeout_sec < max_join_timeout_sec; timeout_sec++)
         {
            /*
             * use 'wl sup_auth_status_ext' command to check the interface status.
             */
            wfa_snprintf(buf, sizeof(buf), "%s/wl -i %s sup_auth_status_ext > %s/.isConnected", WL_BIN_PREFIX_STRING, cmd->intf, NET_FILE_CREATION_PATH);
            system(buf);

            /*
             * The status is saved in a file.  Open the file and check it.
             */
            wfa_snprintf(buf, sizeof(buf), "%s/.isConnected", NET_FILE_CREATION_PATH);
            tmpfile = fopen(buf, "r+");
            if (tmpfile == NULL)
            {
               status = BCMP2P_ERROR;
               goto exit;
            }

            fscanf(tmpfile, "%d", &sup_status);
            fclose(tmpfile);
            if (sup_status == WLC_SUP_KEYED)
            {
               /* STA is associated. */
               b_joined = 1;
               break;
            }
            if (sup_status != 0)
            {
               DPRINT_INFO(WFA_OUT, "%s: sup_status=%d\n", __FUNCTION__, sup_status);
            }

            system("sleep 1");
         }

         if (b_joined)
         {
            /* STA is associated. */
            break;
         }
      }

      if (!b_joined)
      {
         DPRINT_ERR(WFA_ERR, "%s: Join failed!\n", __FUNCTION__);
         status = BCMP2P_ERROR;
         goto exit;
      }
#endif /* defined(BRCM_P2P_EXTSEC) */

      if (!access(IFCONFIG, F_OK))
	      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s %s up", IFCONFIG, cmd->intf);
#ifdef IFCONFIG_ALT
      else if (!access(IFCONFIG_ALT, F_OK))
	      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s %s up", IFCONFIG_ALT, cmd->intf);
#endif
      else
	      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s %s up", IFCONFIG_NOPATH, cmd->intf);

      DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      system(gCmdStr);

      system("sleep 1");

      /* Start the DHCP client. */
#if DHCP_CLIENT_TYPE_DHCPCD
      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s %s", DHCPCD, cmd->intf);
#elif DHCP_CLIENT_TYPE_DHCLIENT
      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s %s &", DHCLIENT, cmd->intf);
#endif
      DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      system(gCmdStr);
   }

exit:
   /* Resume P2P device discovery */
   p2papp_resume_discovery();

   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
      return FALSE;
   }

   /*
    * Then report back to control PC for completion.
    * This does not have failed/error status. The result only tells
    * a completion.
    */
   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);
   return TRUE;
}

/*
 * wfaStaReAssociate():
 *    The function is to force the station wireless I/F to re/associate
 *    with the AP.
 */
int wfaStaReAssociate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *assoc = (dutCommand_t *)caCmdBuf;
   char *ifname = assoc->intf;
   dutCmdResponse_t *staAssocResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "entering wfaStaAssociate ...\n");
   /* use 'ifconfig' command to bring down the interface (linux specific) */
   sprintf(gCmdStr, "ifconfig %s down", ifname);
   system(gCmdStr);

   /* use 'ifconfig' command to bring up the interface (linux specific) */
   sprintf(gCmdStr, "ifconfig %s up", ifname);

   /*
    *  use 'wpa_cli' command to force a 802.11 re/associate
    *  (wpa_supplicant specific)
    */
   sprintf(gCmdStr, "wpa_cli -i%s reassociate", ifname);
   system(gCmdStr);

   /*
    * Then report back to control PC for completion.
    * This does not have failed/error status. The result only tells
    * a completion.
    */
   staAssocResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

/*
 * wfaStaIsConnected():
 *    The function is to check whether the station's wireless I/F has
 *    already connected to an AP.
 */
int wfaStaIsConnected(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
#if !defined(BRCM_P2P_EXTSEC)
   FILE             *tmpfile;
   int              status;
#endif
   dutCmdResponse_t *resp     = &gGenericResp;
   dutCommand_t     *cmd  = (dutCommand_t *)caCmdBuf;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

#if defined(BRCM_P2P_EXTSEC)
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl -i %s status | grep BSSID", WL_BIN_PREFIX_STRING, cmd->intf);
   if (system(gCmdStr) == 0)
      resp->cmdru.connected = 1;
   else
      resp->cmdru.connected = 0;
#else
   /*
    * use 'wl sup_auth_status' command to check the interface status.
    */
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl -i %s sup_auth_status_ext > %s/.isConnected", WL_BIN_PREFIX_STRING, cmd->intf, NET_FILE_CREATION_PATH);
   system(gCmdStr);


   /*
    * The status is saved in a file.  Open the file and check it.
    */
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/.isConnected", NET_FILE_CREATION_PATH);
   tmpfile = fopen(gCmdStr, "r+");
   if(tmpfile == NULL)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_IS_CONNECTED_RESP_TLV, 4, (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return FALSE;
   }

   fscanf(tmpfile, "%d", &status);
   fclose(tmpfile);
 
   DPRINT_INFO(WFA_OUT, "%s: sup_auth_status_ext=%d\n", __FUNCTION__, status);
   if (status == WLC_SUP_KEYED)
   {
      resp->cmdru.connected = 1;
   }
   else
   {
      resp->cmdru.connected = 0;
   }
#endif /* defined(BRCM_P2P_EXTSEC) */

   /*
    * Report back the status: Complete or Failed.
    */
   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_IS_CONNECTED_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   return TRUE;
}

/*
 * wfaStaGetIpConfig():
 * This function is to retriev the ip info including
 *     1. dhcp enable
 *     2. ip address
 *     3. mask
 *     4. primary-dns
 *     5. secondary-dns
 *
 *     The current implementation is to use a script to find these information
 *     and store them in a file.
 */
int wfaStaGetIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    int slen, ret, i = 0;
    dutCommand_t *getIpConf = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *ipconfigResp = &gGenericResp;
    char *ifname = getIpConf->intf;
    caStaGetIpConfigResp_t *ifinfo = &ipconfigResp->cmdru.getIfconfig;

    FILE *tmpfd;
    char string[256];
    char *str;

    DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

    /*
     * check a script file (the current implementation specific)
     */
    ret = access(GET_IP_CONFIG_SCRIPT, F_OK);
    if(ret == -1)
    {
       ipconfigResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;

       DPRINT_ERR(WFA_ERR, "file not exist\n");
       return FALSE;

    }

    strcpy(ifinfo->dns[0], "0");
    strcpy(ifinfo->dns[1], "0");

    /*
     * Run the script file "getipconfig.sh" to check the ip status
     * (current implementation  specific).
     * note: "getipconfig.sh" is only defined for the current implementation
     */
    sprintf(gCmdStr, "%s %s/ipconfig.txt %s %s\n", GET_IP_CONFIG_SCRIPT,
            NET_FILE_CREATION_PATH, ifname, IFCONFIG);

    DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
    system(gCmdStr);

    /* open the output result and scan/retrieve the info */
	sprintf(gCmdStr, "%s/ipconfig.txt", NET_FILE_CREATION_PATH);
    tmpfd = fopen(gCmdStr, "r+");

    if(tmpfd == NULL)
    {
      ipconfigResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return FALSE;
    }

    for(;;)
    {
        if(fgets(string, 256, tmpfd) == NULL)
           break;

        /* check dhcp enabled */
        if(strncmp(string, "dhcpcli", 7) ==0)
        {
            str = strtok(string, "=");
            str = strtok(NULL, "=");
            if(str != NULL)
               ifinfo->isDhcp = 1;
            else
               ifinfo->isDhcp = 0;
        }

        /* find out the ip address */
        if(strncmp(string, "ipaddr", 6) == 0)
        {
            str = strtok(string, "=");
            str = strtok(NULL, " ");
            if(str != NULL)
            {
               wSTRNCPY(ifinfo->ipaddr, str, 15);
               ifinfo->ipaddr[15]='\0';
            }
            else
               wSTRNCPY(ifinfo->ipaddr, "none", 15);
        }
        DPRINT_INFO(WFA_OUT, "%s: ipaddr=%s\n", __FUNCTION__, ifinfo->ipaddr);

        /* check the mask */
        if(strncmp(string, "mask", 4) == 0)
        {
            char ttstr[16];
            char *ttp = ttstr;

            str = strtok_r(string, "=", &ttp);
            if(*ttp != '\0')
            {
               strcpy(ifinfo->mask, ttp);
               slen = strlen(ifinfo->mask);
               ifinfo->mask[slen-1] = '\0';
            }
            else
               strcpy(ifinfo->mask, "none");
        }

        /* find out the dns server ip address */
        if(strncmp(string, "nameserv", 8) == 0)
        {
            char ttstr[16];
            char *ttp = ttstr;

            str = strtok_r(string, " ", &ttp);
            if(str != NULL && i < 2)
            {
               strcpy(ifinfo->dns[i], ttp);
               slen = strlen(ifinfo->dns[i]);
               ifinfo->dns[i][slen-1] = '\0';
            }
            else
               strcpy(ifinfo->dns[i], "none");

            i++;
        }
     }

     /*
      * Report back the results
      */
     ipconfigResp->status = STATUS_COMPLETE;
     wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)ipconfigResp, respBuf);

     *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);


     fclose(tmpfd);
     return TRUE;
}

/*
 * wfaStaSetIpConfig():
 *   The function is to set the ip configuration to a wireless I/F.
 *   1. IP address
 *   2. Mac address
 *   3. default gateway
 *   4. dns nameserver (pri and sec).
 */
int wfaStaSetIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *setIpConf = (dutCommand_t *)caCmdBuf;
   caStaSetIpConfig_t *ipconfig = &setIpConf->cmdsu.ipconfig;
   dutCmdResponse_t *staSetIpResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   if (!ipconfig->isDhcp)
   {
      /*
       * Use command 'ifconfig' to configure the interface ip address, mask.
       * (Linux specific).
       */
      if (!access(IFCONFIG, F_OK))
         sprintf(gCmdStr, "%s %s %s netmask %s > /dev/null 2>&1 ", IFCONFIG, ipconfig->intf, ipconfig->ipaddr, ipconfig->mask);
#ifdef IFCONFIG_ALT
      else if (!access(IFCONFIG_ALT, F_OK))
         sprintf(gCmdStr, "%s %s %s netmask %s > /dev/null 2>&1 ", IFCONFIG_ALT, ipconfig->intf, ipconfig->ipaddr, ipconfig->mask);
#endif
      else
         sprintf(gCmdStr, "%s %s %s netmask %s > /dev/null 2>&1 ", IFCONFIG_NOPATH, ipconfig->intf, ipconfig->ipaddr, ipconfig->mask);

      DPRINT_INFO(WFA_OUT, "cmd 1 is %s\n",gCmdStr);
      system(gCmdStr);

      /* use command 'route add' to set set gatewway (linux specific) */
      if(ipconfig->defGateway[0] != '\0')
      {
         sprintf(gCmdStr, "%s add default gw %s > /dev/null 2>&1", ROUTE, ipconfig->defGateway);
         system(gCmdStr);
      }

#if DNS_SUPPORTED
      /* set dns (linux specific) */
      sprintf(gCmdStr, "cp /etc/resolv.conf /tmp/resolv.conf.bk");
      system(gCmdStr);
      sprintf(gCmdStr, "echo nameserv %s > /etc/resolv.conf", ipconfig->pri_dns);
      system(gCmdStr);
      sprintf(gCmdStr, "echo nameserv %s >> /etc/resolv.conf", ipconfig->sec_dns);
      system(gCmdStr);
#else
      DPRINT_INFO(WFA_OUT, "DNS not supported!\n");
#endif
   }

   /*
    * report status
    */
   staSetIpResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_IP_CONFIG_RESP_TLV, 4, (BYTE *)staSetIpResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

/*
 * wfaStaVerifyIpConnection():
 * The function is to verify if the station has IP connection with an AP by
 * send ICMP/pings to the AP.
 */
int wfaStaVerifyIpConnection(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *verip = (dutCommand_t *)caCmdBuf;
   dutCmdResponse_t *verifyIpResp = &gGenericResp;

#ifndef WFA_PING_UDP_ECHO_ONLY
   char strout[64], *pcnt;
   FILE *tmpfile;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /* set timeout value in case not set */
   if(verip->cmdsu.verifyIp.timeout <= 0)
   {
        verip->cmdsu.verifyIp.timeout = 10;
   }

   /* execute the ping command  and pipe the result to a tmp file */
   sprintf(gCmdStr, "ping %s -c 3 -W %u | grep loss | cut -f3 -d, 1>& %s/pingout.txt", verip->cmdsu.verifyIp.dipaddr, verip->cmdsu.verifyIp.timeout, NET_FILE_CREATION_PATH);
   system(gCmdStr);

   /* scan/check the output */
   sprintf(gCmdStr, "%s/pingout.txt", NET_FILE_CREATION_PATH);
   tmpfile = fopen(gCmdStr, "r+");
   if(tmpfile == NULL)
   {
      verifyIpResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)verifyIpResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return FALSE;
   }

   verifyIpResp->status = STATUS_COMPLETE;
   if(fscanf(tmpfile, "%s", strout) == EOF)
       verifyIpResp->cmdru.connected = 0;
   else
   {
       pcnt = strtok(strout, "%");

       /* if the loss rate is 100%, not able to connect */
       if(atoi(pcnt) == 100)
          verifyIpResp->cmdru.connected = 0;
       else
          verifyIpResp->cmdru.connected = 1;
   }

   fclose(tmpfile);
#else
   int btSockfd;
   struct pollfd fds[2];
   int timeout = 2000;
   char anyBuf[64];
   struct sockaddr_in toAddr;
   int done = 1, cnt = 0, ret, nbytes;

   verifyIpResp->status = STATUS_COMPLETE;
   verifyIpResp->cmdru.connected = 0;

   btSockfd = wfaCreateUDPSock("127.0.0.1", WFA_UDP_ECHO_PORT);

   if(btSockfd == -1)
   {
      verifyIpResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)verifyIpResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;
      return FALSE;;
   }

   toAddr.sin_family = AF_INET;
   toAddr.sin_addr.s_addr = inet_addr(verip->cmdsu.verifyIp.dipaddr);
   toAddr.sin_port = htons(WFA_UDP_ECHO_PORT);

   while(done)
   {
       wfaTrafficSendTo(btSockfd, (char *)anyBuf, 64, (struct sockaddr *)&toAddr);
       cnt++;

       fds[0].fd = btSockfd;
       fds[0].events = POLLIN | POLLOUT;

       ret = poll(fds, 1, timeout);
       switch(ret)
       {
           case 0:
             /* it is time out, count a packet lost*/
           break;
           case -1:
             /* it is an error */
           default:
           {
              switch(fds[0].revents)
              {
                  case POLLIN:
                  case POLLPRI:
                  case POLLOUT:
                  nbytes = wfaTrafficRecv(btSockfd, (char *)anyBuf, (struct sockaddr *)&toAddr);
                  if(nbytes != 0)
                      verifyIpResp->cmdru.connected = 1;
                      done = 0;
                  break;
                  default:
                  /* errors but not care */
                   ;
              }
           }
       }
       if(cnt == 3)
       {
          done = 0;
       }
   }

#endif

   wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)verifyIpResp, respBuf);

   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   return TRUE;
}

/*
 * wfaStaGetMacAddress()
 *    This function is to retrieve the MAC address of a wireless I/F.
 */
int wfaStaGetMacAddress(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *getMac = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *getmacResp = &gGenericResp;
    char *str = NULL;
    char *ifname = getMac->intf;

    FILE *tmpfd;
    char string[128];
    BCMP2P_BOOL found = FALSE;

    DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

    /*
     * run the script "getipconfig.sh" to find out the mac
     */
    //sprintf(gCmdStr, "getipconfig.sh /tmp/ipconfig.txt %s", ifname);
    if (!access(IFCONFIG, F_OK))
        sprintf(gCmdStr, "%s %s > %s/ipconfig.txt ", IFCONFIG, ifname, NET_FILE_CREATION_PATH);
#ifdef IFCONFIG_ALT
    else if (!access(IFCONFIG_ALT, F_OK))
        sprintf(gCmdStr, "%s %s > %s/ipconfig.txt ", IFCONFIG_ALT, ifname, NET_FILE_CREATION_PATH);
#endif
    else
	    sprintf(gCmdStr, "%s %s > %s/ipconfig.txt ", IFCONFIG_NOPATH, ifname, NET_FILE_CREATION_PATH);

    system(gCmdStr);
    sprintf(gCmdStr, "%s/ipconfig.txt", NET_FILE_CREATION_PATH);
    tmpfd = fopen(gCmdStr, "r+");
    getmacResp->status = STATUS_ERROR;
    if(tmpfd == NULL)
    {
      getmacResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_MAC_ADDRESS_RESP_TLV, 4, (BYTE *)getmacResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return FALSE;
    }

	while(found == FALSE && (fgets(string, sizeof(string), tmpfd) != NULL)) {
		str = strtok(string, " ");
		while(str) {
			if (strcmp(str,"ether") == 0 || strcmp(str,"HWaddr") == 0) {
				found = TRUE;
				break;
			} else {
				str = strtok(NULL, " ");
			}
		}
	}

    /* get mac */
    if(str)
    {
       str = strtok(NULL, " ");
       strcpy(getmacResp->cmdru.mac, str);
       getmacResp->status = STATUS_COMPLETE;
    }

    wfaEncodeTLV(WFA_STA_GET_MAC_ADDRESS_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)getmacResp, respBuf);

    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

    fclose(tmpfd);
    return TRUE;
}

/*
 * wfaStaGetStats():
 * The function is to retrieve the statistics of the I/F's layer 2 txFrames,
 * rxFrames, txMulticast, rxMulticast, fcsErrors/crc, and txRetries.
 * Currently there is not definition how to use these info.
 */
int wfaStaGetStats(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *statsResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   statsResp->status = STATUS_ERROR;
   wfaEncodeTLV(WFA_STA_GET_STATS_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)statsResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);


   return TRUE;
}

/*
 * wfaSetEncryption():
 *   The function is to set the wireless interface with WEP or none.
 *
 *   Since WEP is optional test, current function is only used for
 *   resetting the Security to NONE/Plaintext (OPEN). To test WEP,
 *   this function should be replaced by the next one (wfaSetEncryption1())
 *
 *   Input parameters:
 *     1. I/F
 *     2. ssid
 *     3. encpType - wep or none
 *     Optional:
 *     4. key1
 *     5. key2
 *     6. key3
 *     7. key4
 *     8. activeKey Index
 */

int wfaSetEncryption1(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
   dutCmdResponse_t *setEncrypResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /*
    * disable the network first
    */
   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", setEncryp->intf);
   system(gCmdStr);

   /*
    * set SSID
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", setEncryp->intf, setEncryp->ssid);
   system(gCmdStr);

   /*
    * Tell the supplicant for infrastructure mode (1)
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 mode 0", setEncryp->intf);
   system(gCmdStr);

   /*
    * set Key management to NONE (NO WPA) for plaintext or WEP
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt NONE", setEncryp->intf);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", setEncryp->intf);
   system(gCmdStr);

   setEncrypResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

/*
 *  Since WEP is optional, this function could be used to replace
 *  wfaSetEncryption() if necessary.
 */
int wfaSetEncryption(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
   dutCmdResponse_t *setEncrypResp = &gGenericResp;
   int i;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /*
    * disable the network first
    */
   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", setEncryp->intf);
   system(gCmdStr);

   /*
    * set SSID
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", setEncryp->intf, setEncryp->ssid);
   system(gCmdStr);

   /*
    * Tell the supplicant for infrastructure mode (1)
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 mode 0", setEncryp->intf);
   system(gCmdStr);

   /*
    * set Key management to NONE (NO WPA) for plaintext or WEP
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt NONE", setEncryp->intf);
   system(gCmdStr);

   /* set keys */
   if(setEncryp->encpType == 1)
   {
      for(i=0; i<4; i++)
      {
         if(setEncryp->keys[i][0] != '\0')
         {
             sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_key%i %s",
                   setEncryp->intf, i, setEncryp->keys[i]);
             system(gCmdStr);
         }
      }

      /* set active key */
      i = setEncryp->activeKeyIdx;
      if(setEncryp->keys[i][0] != '\0')
      {
          sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_tx_keyidx %i",
            setEncryp->intf, setEncryp->activeKeyIdx);
          system(gCmdStr);
      }
   }
   else /* clearly remove the keys -- reported by p.schwann */
   {
      for(i = 0; i < 4; i++)
      {
          sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_key%i \"\"", setEncryp->intf, i);
          system(gCmdStr);
      }
   }

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", setEncryp->intf);
   system(gCmdStr);

   setEncrypResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

/*
 * wfaStaSetEapTLS():
 *   This is to set
 *   1. ssid
 *   2. encrypType - tkip or aes-ccmp
 *   3. keyManagementType - wpa or wpa2
 *   4. trustedRootCA
 *   5. clientCertificate
 */
int wfaStaSetEapTLS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapTLS_t *setTLS = (caStaSetEapTLS_t *)caCmdBuf;
   char *ifname = setTLS->intf;
   dutCmdResponse_t *setEapTlsResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /*
    * need to store the trustedROOTCA and clientCertificate into a file first.
    */
#ifdef WFA_NEW_CLI_FORMAT
   sprintf(gCmdStr, "wfa_set_eaptls -i %s %s %s %s", ifname, setTLS->ssid, setTLS->trustedRootCA, setTLS->clientCertificate);
   system(gCmdStr);
#else

   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
   system(gCmdStr);

   /* ssid */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setTLS->ssid);
   system(gCmdStr);

   /* key management */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   system(gCmdStr);

   /* protocol WPA */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap TLS", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ca_cert '\"%s\"'", ifname, setTLS->trustedRootCA);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"wifi-user@wifilabs.local\"'", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 private_key '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setTLS->clientCertificate);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 private_key_passwd '\"wifi\"'", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
   system(gCmdStr);
#endif

   setEapTlsResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPTLS_RESP_TLV, 4, (BYTE *)setEapTlsResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

/*
 * The function is to set
 *   1. ssid
 *   2. passPhrase
 *   3. keyMangementType - wpa/wpa2
 *   4. encrypType - tkip or aes-ccmp
 */
int wfaStaSetPSK(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetPSK_t    *setPSK = (caStaSetPSK_t *)caCmdBuf;
   dutCmdResponse_t *resp   = &gGenericResp;
   BCMP2P_STATUS    status  = BCMP2P_SUCCESS;
#if !defined(BRCM_P2P_EXTSEC)
   char             buf[128];
#endif

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);
   system("date");

   /* Only WPA2-PSK is supported. */
   if (strcmp("wpa2", setPSK->keyMgmtType) != 0)
   {
      status = BCMP2P_ERROR;
      goto exit;
   }

#if defined(BRCM_P2P_EXTSEC)
   strncpy(g_passPhrase, (const char *)setPSK->passphrase, WFA_PSK_PP_LEN);
#else
   /* WPS-PSK2 */
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl -i %s wpa_auth 0x80", WL_BIN_PREFIX_STRING, setPSK->intf);
   DPRINT_INFO(WFA_OUT, "%s: ---wl -i %s wpa_auth 0x80\n", __FUNCTION__, setPSK->intf);
   system(gCmdStr);

   /* Enable WPA supplicant. */
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl -i %s sup_wpa 1", WL_BIN_PREFIX_STRING, setPSK->intf);
   DPRINT_INFO(WFA_OUT, "%s: ---wl -i %s sup_wpa 1\n", __FUNCTION__, setPSK->intf);
   system(gCmdStr);

   /* Set authentication mode - Open. */
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl -i %s auth 0", WL_BIN_PREFIX_STRING, setPSK->intf);
   DPRINT_INFO(WFA_OUT, "%s: ---wl -i %s auth 0\n", __FUNCTION__, setPSK->intf);
   system(gCmdStr);

   /* Set encryption type. */
   if (setPSK->encpType == ENCRYPT_TKIP)
   {
	    wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl -i %s wsec 2", WL_BIN_PREFIX_STRING, setPSK->intf);
        DPRINT_INFO(WFA_OUT, "%s: ---wl -i %s wsec 2\n", __FUNCTION__, setPSK->intf);
		system(gCmdStr);

   }
   else if (setPSK->encpType == ENCRYPT_AESCCMP)
   {
        wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl -i %s wsec 4", WL_BIN_PREFIX_STRING, setPSK->intf);
		DPRINT_INFO(WFA_OUT, "%s: ---wl -i %s wsec 4\n", __FUNCTION__, setPSK->intf);
		system(gCmdStr);
   }
   else
   {
      status = BCMP2P_ERROR;
      goto exit;
   }

   /* Set the PMK (pairwise master key). */
   DPRINT_INFO(WFA_OUT, "%s: ---wl -i %s set_pmk %s\n", __FUNCTION__, setPSK->intf, setPSK->passphrase);
   wfa_snprintf(buf, sizeof(buf), "%s/wl -i %s set_pmk %s", WL_BIN_PREFIX_STRING, setPSK->intf, setPSK->passphrase);
   system(buf);
#endif /* defined(BRCM_P2P_EXTSEC) */


exit:
   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
      return FALSE;
   }

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);


   return TRUE;
}

/*
 * wfaStaGetInfo():
 * Get vendor specific information in name/value pair by a wireless I/F.
 */
int wfaStaGetInfo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp    = &gGenericResp;
   dutCommand_t     *getInfo = (dutCommand_t *)caCmdBuf;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /*
    * Normally this is called to retrieve the vendor information
    * from a interface.
    */
   wfa_snprintf(resp->cmdru.info, sizeof(resp->cmdru.info),
                "interface,%s,vendor,Broadcom", getInfo->intf);

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_GET_INFO_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}

/*
 * wfaStaSetEapTTLS():
 *   This is to set
 *   1. ssid
 *   2. username
 *   3. passwd
 *   4. encrypType - tkip or aes-ccmp
 *   5. keyManagementType - wpa or wpa2
 *   6. trustedRootCA
 */
int wfaStaSetEapTTLS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapTTLS_t *setTTLS = (caStaSetEapTTLS_t *)caCmdBuf;
   char *ifname = setTTLS->intf;
   dutCmdResponse_t *setEapTtlsResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

#ifdef WFA_NEW_CLI_FORMAT
   sprintf(gCmdStr, "wfa_set_eapttls %s %s %s %s %s", ifname, setTTLS->ssid, setTTLS->username, setTTLS->passwd, setTTLS->trustedRootCA);
   system(gCmdStr);
#else

   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setTTLS->ssid);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setTTLS->username);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setTTLS->passwd);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   system(gCmdStr);

/* This may not need to set. if it is not set, default to take all */
//   sprintf(cmdStr, "wpa_cli -i %s set_network 0 pairwise '\"%s\"", ifname, setTTLS->encrptype);
//   system(cmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap TTLS", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ca_cert '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setTTLS->trustedRootCA);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA", ifname);
   system(gCmdStr);

//   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 anonymous_identity '\"anonymous\"'", ifname);
//   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase2 '\"auth=MSCHAPV2\"'", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
   system(gCmdStr);
#endif

   setEapTtlsResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPTTLS_RESP_TLV, 4, (BYTE *)setEapTtlsResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

/*
 * wfaStaSetEapSIM():
 *   This is to set
 *   1. ssid
 *   2. user name
 *   3. passwd
 *   4. encrypType - tkip or aes-ccmp
 *   5. keyMangementType - wpa or wpa2
 */
int wfaStaSetEapSIM(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapSIM_t *setSIM = (caStaSetEapSIM_t *)caCmdBuf;
   char *ifname = setSIM->intf;
   dutCmdResponse_t *setEapSimResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

#ifdef WFA_NEW_CLI_FORMAT
   sprintf(gCmdStr, "wfa_set_eapsim %s %s %s %s", ifname, setSIM->ssid, setSIM->username, setSIM->encrptype);
   system(gCmdStr);
#else

   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setSIM->ssid);
   system(gCmdStr);


   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setSIM->username);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 pairwise '\"%s\"'", ifname, setSIM->encrptype);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap SIM", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
   system(gCmdStr);
#endif

   setEapSimResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPSIM_RESP_TLV, 4, (BYTE *)setEapSimResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

/*
 * wfaStaSetPEAP()
 *   This is to set
 *   1. ssid
 *   2. user name
 *   3. passwd
 *   4. encryType - tkip or aes-ccmp
 *   5. keyMgmtType - wpa or wpa2
 *   6. trustedRootCA
 *   7. innerEAP
 *   8. peapVersion
 */
int wfaStaSetPEAP(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapPEAP_t *setPEAP = (caStaSetEapPEAP_t *)caCmdBuf;
   char *ifname = setPEAP->intf;
   dutCmdResponse_t *setPeapResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

#ifdef WFA_NEW_CLI_FORMAT
   sprintf(gCmdStr, "wfa_set_peap %s %s %s %s %s %s %i %s", ifname, setPEAP->ssid, setPEAP->username,
                                                          setPEAP->passwd, setPEAP->trustedRootCA,
							  setPEAP->encrptype, setPEAP->peapVersion,
							  setPEAP->innerEAP);
   system(gCmdStr);
#else

   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setPEAP->ssid);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap PEAP", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 anonymous_identity '\"anonymous\"' ", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setPEAP->username);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setPEAP->passwd);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ca_cert '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setPEAP->trustedRootCA);
   system(gCmdStr);

   /* if this not set, default to set support all */
   //sprintf(gCmdStr, "wpa_cli -i %s set_network 0 pairwise '\"%s\"'", ifname, setPEAP->encrptype);
   //system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase1 '\"peaplabel=%i\"'", ifname, setPEAP->peapVersion);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase2 '\"auth=%s\"'", ifname, setPEAP->innerEAP);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
   system(gCmdStr);
#endif

   setPeapResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PEAP_RESP_TLV, 4, (BYTE *)setPeapResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

/*
 * wfaStaSetUAPSD()
 *    This is to set
 *    1. acBE
 *    2. acBK
 *    3. acVI
 *    4. acVO
 */
int wfaStaSetUAPSD(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   caStaSetUAPSD_t *setUAPSD = (caStaSetUAPSD_t *)caCmdBuf;
   int p2p_mode;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /* save current P2P mode and set mode to idle */
   p2p_mode = wfaStaGetP2pMode();
   wfaStaSetP2pMode(P2P_MODE_IDLE);

   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl down", WL_BIN_PREFIX_STRING);
   DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
   system(gCmdStr);

   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl apsta 0", WL_BIN_PREFIX_STRING);
   DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
   system(gCmdStr);

   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl ap 0", WL_BIN_PREFIX_STRING);
   DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
   system(gCmdStr);

   BCMP2PStaStoreUAPSD(p2papp_dev_hdl, setUAPSD->maxSPLength, setUAPSD->acBE,
    setUAPSD->acBK, setUAPSD->acVI, setUAPSD->acVO);

   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl ap 1", WL_BIN_PREFIX_STRING);
   DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
   system(gCmdStr);

   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl apsta 1", WL_BIN_PREFIX_STRING);
   DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
   system(gCmdStr);

   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl plcphdr auto", WL_BIN_PREFIX_STRING);
   DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
   system(gCmdStr);

   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl up", WL_BIN_PREFIX_STRING);
   DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
   system(gCmdStr);

   /* Turn off MPC because "wl apsta 1" will automatically turn it on. */
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl mpc 0", WL_BIN_PREFIX_STRING);
   DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
   system(gCmdStr);

   /* Request the GO to buffer lots of data (600 beacon intervals/60 seconds).
    * This is necessary for P2P test cases 6.1.13 and 7.1.5 which require the
    * GO to buffer large amounts of ping traffic. Perform this on both the
    * legacy and P2P interfaces.
    */
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl assoc_listen 600", WL_BIN_PREFIX_STRING);
   DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
   system(gCmdStr);

   BCMP2PSetListenInterval(p2papp_dev_hdl, 600);

   /* restore P2P mode */
   wfaStaSetP2pMode(p2p_mode);

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_UAPSD_RESP_TLV, 4, (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;
   return TRUE;
}

int wfaDeviceGetInfo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *infoResp = &gGenericResp;
   char line[80];
   char *version;
   FILE *pipe;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   memset(&infoResp->cmdru.devInfo, 0, sizeof(infoResp->cmdru.devInfo));
   strncpy(infoResp->cmdru.devInfo.vendor, "Broadcom", sizeof(infoResp->cmdru.devInfo.vendor));

   /* Read into 'model' the 2..16th characters from the output of 'uname -r'.
    * The size of infoResp->cmdru.devInfo.model is only 16 characters.
    */
   pipe = popen("uname -r", "r");
   if (pipe == NULL)
   {
       DPRINT_ERR(WFA_OUT, "%s: popen failed\n", __FUNCTION__);
       return FALSE;
   }
   fscanf(pipe, "%s", line);
   pclose(pipe);
   memset(infoResp->cmdru.devInfo.model, 0, sizeof(infoResp->cmdru.devInfo.model));
   strncpy(infoResp->cmdru.devInfo.model, line + 2, sizeof(infoResp->cmdru.devInfo.model));
   infoResp->cmdru.devInfo.model[sizeof(infoResp->cmdru.devInfo.model)-1] = '\0';

   /* Read the trailing 7 characters from the first output line from the
    * "./wl ver" command.
    * The size of infoResp->cmdru.devInfo.version is only 8 characters.
    *
    * This version string is generated by the 'wl' utility from a constant in
    * epivers.h which is generated from src/tools/release/producttag.txt.
    */
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl ver", WL_BIN_PREFIX_STRING);
   pipe = popen(gCmdStr, "r");
   if (pipe == NULL)
   {
       DPRINT_ERR(WFA_OUT, "%s: popen failed (2)\n", __FUNCTION__);
       return FALSE;
   }
   memset(line, 0, sizeof(line));
   fgets(line, sizeof(line), pipe);
   pclose(pipe);
/*   version = line + strlen(line) - 1 - 7; */
   version = (char*)P2PAPP_VERSION_STR;
   DPRINT_INFO(WFA_OUT, "%s: line=%s ver=%s\n", __FUNCTION__, line, version);
   strncpy(infoResp->cmdru.devInfo.version, version, sizeof(infoResp->cmdru.devInfo.version));

   infoResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_DEVICE_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   return TRUE;

}

/*
 * This funciton is to retrieve a list of interfaces and return
 * the list back to Agent control.
 * ********************************************************************
 * Note: We intend to make this WLAN interface name as a hardcode name.
 * Therefore, for a particular device, you should know and change the name
 * for that device while doing porting. The MACRO "WFA_STAUT_IF" is defined in
 * the file "inc/wfa_ca.h". If the device OS is not linux-like, this most
 * likely is hardcoded just for CAPI command responses.
 * *******************************************************************
 *
 */
int wfaDeviceListIF(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *infoResp = &gGenericResp;
   dutCommand_t *ifList = (dutCommand_t *)caCmdBuf;
   caDeviceListIFResp_t *ifListResp = &infoResp->cmdru.ifList;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   switch(ifList->cmdsu.iftype)
   {
      case IF_80211:
      {
         infoResp->status = STATUS_COMPLETE;
         ifListResp->iftype = IF_80211;

         p2papp_get_wlan_ifname(ifListResp->ifs[0], sizeof(ifListResp->ifs[0]));
         strcpy(ifListResp->ifs[1], "NULL");
         strcpy(ifListResp->ifs[2], "NULL");
      }
      break;

      default:
      {
         infoResp->status = STATUS_ERROR;
         wfaEncodeTLV(WFA_DEVICE_LIST_IF_RESP_TLV, 4, (BYTE *)infoResp, respBuf);
         *respLen = WFA_TLV_HDR_LEN + 4;

         return TRUE;
      }
   }

   wfaEncodeTLV(WFA_DEVICE_LIST_IF_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   return TRUE;
}

int wfaStaDebugSet(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *debugResp = &gGenericResp;
   dutCommand_t *debugSet = (dutCommand_t *)caCmdBuf;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   if(debugSet->cmdsu.dbg.state == 1) /* enable */
      wfa_defined_debug |= debugSet->cmdsu.dbg.level;
   else
      wfa_defined_debug = (~debugSet->cmdsu.dbg.level & wfa_defined_debug);

   debugResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)debugResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);


   return TRUE;
}


/*
 *   wfaStaGetBSSID():
 *     This function is to retrieve BSSID of a specific wireless I/F.
 */
int wfaStaGetBSSID(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   char string[64];
   FILE *tmpfd;
   dutCmdResponse_t *resp = &gGenericResp;
   dutCommand_t     *cmd  = (dutCommand_t *)caCmdBuf;
   char buf[64];
   int rc;


   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /* retrieve the BSSID */
   wfa_snprintf(buf, sizeof(buf), "%s/wl -i %s bssid > %s/bssid.txt", WL_BIN_PREFIX_STRING, cmd->intf, NET_FILE_CREATION_PATH);
   system(buf);

   wfa_snprintf(buf, sizeof(buf), "%s/bssid.txt", NET_FILE_CREATION_PATH);
   tmpfd = fopen(buf, "r+");
   if(tmpfd == NULL)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_BSSID_RESP_TLV, 4, (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return FALSE;
   }

   rc = fscanf(tmpfd, "%s", string);
   if(rc == EOF)
   {
      strncpy(resp->cmdru.bssid, "00:00:00:00:00:00", sizeof(resp->cmdru.bssid));
   }
   else
   {
      strncpy(resp->cmdru.bssid, string, sizeof(resp->cmdru.bssid));
   }

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_GET_BSSID_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   fclose(tmpfd);
   return TRUE;
}

/*
 * wfaStaSetIBSS()
 *    This is to set
 *    1. ssid
 *    2. channel
 *    3. encrypType - none or wep
 *    optional
 *    4. key1
 *    5. key2
 *    6. key3
 *    7. key4
 *    8. activeIndex - 1, 2, 3, or 4
 */
int wfaStaSetIBSS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetIBSS_t *setIBSS = (caStaSetIBSS_t *)caCmdBuf;
   dutCmdResponse_t *setIbssResp = &gGenericResp;
   int i;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /*
    * disable the network first
    */
   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", setIBSS->intf);
   system(gCmdStr);

   /*
    * set SSID
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", setIBSS->intf, setIBSS->ssid);
   system(gCmdStr);

   /*
    * Set channel for IBSS
    */
   sprintf(gCmdStr, "iwconfig %s channel %i", setIBSS->intf, setIBSS->channel);
   system(gCmdStr);

   /*
    * Tell the supplicant for IBSS mode (1)
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 mode 1", setIBSS->intf);
   system(gCmdStr);

   /*
    * set Key management to NONE (NO WPA) for plaintext or WEP
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt NONE", setIBSS->intf);
   system(gCmdStr);

   if(setIBSS->encpType == 1)
   {
      for(i=0; i<4; i++)
      {
         if(strlen(setIBSS->keys[i]) ==5 || strlen(setIBSS->keys[i]) == 13)
         {
             sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_key%i \"%s\"",
                setIBSS->intf, i, setIBSS->keys[i]);
             system(gCmdStr);
         }
      }

      i = setIBSS->activeKeyIdx;
      if(strlen(setIBSS->keys[i]) ==5 || strlen(setIBSS->keys[i]) == 13)
      {
         sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_tx_keyidx %i",
            setIBSS->intf, setIBSS->activeKeyIdx);
         system(gCmdStr);
      }
   }

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", setIBSS->intf);
   system(gCmdStr);

   setIbssResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_IBSS_RESP_TLV, 4, (BYTE *)setIbssResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

/*
 *  wfaSetMode():
 *  The function is to set the wireless interface with a given mode (possible
 *  adhoc)
 *  Input parameters:
 *    1. I/F
 *    2. ssid
 *    3. mode adhoc or managed
 *    4. encType
 *    5. channel
 *    6. key(s)
 *    7. active  key
 */
int wfaStaSetMode(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetMode_t *setmode = (caStaSetMode_t *)caCmdBuf;
   dutCmdResponse_t *SetModeResp = &gGenericResp;
   int i;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /*
    * bring down the interface
    */
   sprintf(gCmdStr, "ifconfig %s down",setmode->intf);
   system(gCmdStr);

   /*
    * distroy the interface
    */
   sprintf(gCmdStr, "wlanconfig %s destroy",setmode->intf);
   system(gCmdStr);


   /*
    * re-create the interface with the given mode
    */
   if(setmode->mode == 1)
        sprintf(gCmdStr, "wlanconfig %s create wlandev wifi0 wlanmode adhoc",setmode->intf);
   else
        sprintf(gCmdStr, "wlanconfig %s create wlandev wifi0 wlanmode managed",setmode->intf);

   system(gCmdStr);
   if(setmode->encpType == ENCRYPT_WEP)
    {
      int j = setmode->activeKeyIdx;
      for(i=0; i<4; i++)
      {
         if(setmode->keys[i][0] != '\0')
         {
             sprintf(gCmdStr, "iwconfig  %s key  s:%s",
                   setmode->intf, setmode->keys[i]);
             system(gCmdStr);
         }
      /* set active key */
         if(setmode->keys[j][0] != '\0')
             sprintf(gCmdStr, "iwconfig  %s key  s:%s",
                   setmode->intf, setmode->keys[j]);
         system(gCmdStr);
      }

    }
   /*
    * Set channel for IBSS
    */
    if(setmode->channel)
    {
      sprintf(gCmdStr, "iwconfig %s channel %i", setmode->intf, setmode->channel);
      system(gCmdStr);
    }


   /*
    * set SSID
    */
   sprintf(gCmdStr, "iwconfig %s essid %s", setmode->intf, setmode->ssid);
   system(gCmdStr);

   /*
    * bring up the interface
    */
   sprintf(gCmdStr, "ifconfig %s up",setmode->intf);
   system(gCmdStr);

   SetModeResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_MODE_RESP_TLV, 4, (BYTE *)SetModeResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

int wfaStaSetPwrSave(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetPwrSave_t *setps = (caStaSetPwrSave_t *)caCmdBuf;
   dutCmdResponse_t *SetPSResp = &gGenericResp;

   sprintf(gCmdStr, "iwconfig %s power %s", setps->intf, setps->mode);
   system(gCmdStr);


   SetPSResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PWRSAVE_RESP_TLV, 4, (BYTE *)SetPSResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

int wfaStaUpload(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaUpload_t *upload = &((dutCommand_t *)caCmdBuf)->cmdsu.upload;
   dutCmdResponse_t *upLoadResp = &gGenericResp;
   caStaUploadResp_t *upld = &upLoadResp->cmdru.uld;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   if(upload->type == WFA_UPLOAD_VHSO_RPT)
   {
       int rbytes;
       /*
        * if asked for the first packet, always to open the file
        */
       if(upload->next == 1)
       {
          if(e2efp != NULL)
          {
              fclose(e2efp);
              e2efp = NULL;
          }

          e2efp = fopen(e2eResults, "r");
       }

       if(e2efp == NULL)
       {
           upLoadResp->status = STATUS_ERROR;
           wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, 4, (BYTE *)upLoadResp, respBuf);
           *respLen = WFA_TLV_HDR_LEN + 4;
           return FALSE;
       }

       rbytes = fread(upld->bytes, 1, 256, e2efp);

       if(rbytes < 256)
       {
           /*
            * this means no more bytes after this read
            */
           upld->seqnum = 0;
           fclose(e2efp);
           e2efp=NULL;
       }
       else
       {
           upld->seqnum = upload->next;
       }

       upld->nbytes = rbytes;

       upLoadResp->status = STATUS_COMPLETE;
       wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)upLoadResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
   }
   else
   {
       upLoadResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, 4, (BYTE *)upLoadResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;
   }

   return TRUE;
}

/*
 * wfaStaSetWMM()
 *  TO be ported on a specific plaform for the DUT
 *  This is to set the WMM related parameters at the DUT.
 *  Currently the function is used for GROUPS WMM-AC and WMM general configuration for setting RTS Threshhold, Fragmentation threshold and wmm (ON/OFF)
 *  It is expected that this function will set all the WMM related parametrs for a particular GROUP .
 */
int wfaStaSetWMM(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
#ifdef WFA_WMM_AC
    caStaSetWMM_t *setwmm = (caStaSetWMM_t *)caCmdBuf;
    char *ifname = setwmm->intf;
    dutCmdResponse_t *setwmmResp = &gGenericResp;
    //IEEEtypes_WMM_TSPEC_t tspec;

    switch(setwmm->group)
    {
    case GROUP_WMMAC:
	if (setwmm->send_trig)
	{
	    int Sockfd;
	    struct sockaddr_in psToAddr;
	    unsigned int TxMsg[512];

            Sockfd = wfaCreateUDPSock(setwmm->dipaddr, 12346);
	    memset(&psToAddr, 0, sizeof(psToAddr));
	    psToAddr.sin_family = AF_INET;
	    psToAddr.sin_addr.s_addr = inet_addr(setwmm->dipaddr);
	    psToAddr.sin_port = htons(12346);


	    switch (setwmm->trig_ac)
	    {
	    case WMMAC_AC_VO:
	        wfaTGSetPrio(Sockfd, 7);
	        create_apts_msg(APTS_CK_VO, TxMsg, 0);
	        printf("\r\nSending AC_VO trigger packet\n");
	        break;

	    case WMMAC_AC_VI:
	        wfaTGSetPrio(Sockfd, 5);
	        create_apts_msg(APTS_CK_VI, TxMsg, 0);
	        printf("\r\nSending AC_VI trigger packet\n");
	        break;

	    case WMMAC_AC_BK:
	        wfaTGSetPrio(Sockfd, 2);
	        create_apts_msg(APTS_CK_BK, TxMsg, 0);
	        printf("\r\nSending AC_BK trigger packet\n");
	        break;

	    default:
            case WMMAC_AC_BE:
	        wfaTGSetPrio(Sockfd, 0);
	        create_apts_msg(APTS_CK_BE, TxMsg, 0);
	        printf("\r\nSending AC_BE trigger packet\n");
	        break;
            }

	    sendto(Sockfd, TxMsg, 256, 0, (struct sockaddr *)&psToAddr,
	           sizeof(struct sockaddr));
	    close(Sockfd);
	    usleep(1000000);
	}
	else if (setwmm->action == WMMAC_ADDTS)
        {
	    //wmmtspec_t* pCmdTspec = &(setwmm->actions.addts.tspec);
            printf("ADDTS AC PARAMS: dialog id: %d, TID: %d, "
	           "DIRECTION: %d, PSB: %d, UP: %d, "
		   "Fixed %d, MSDU Size: %d, Max MSDU Size %d, "
		   "MIN SERVICE INTERVAL: %d, MAX SERVICE INTERVAL: %d, "
		   "INACTIVITY: %d, SUSPENSION %d, SERVICE START TIME: %d, "
		   "MIN DATARATE: %d, MEAN DATA RATE: %d, PEAK DATA RATE: %d, "
	           "BURSTSIZE: %d, DELAY BOUND: %d, PHYRATE: %d, SPLUSBW: %f, "
		   "MEDIUM TIME: %d, ACCESSCAT: %d\n",
		   setwmm->actions.addts.dialog_token,
		   setwmm->actions.addts.tspec.tsinfo.TID,
		   setwmm->actions.addts.tspec.tsinfo.direction,
		   setwmm->actions.addts.tspec.tsinfo.PSB,
		   setwmm->actions.addts.tspec.tsinfo.UP,
		   setwmm->actions.addts.tspec.Fixed,
		   setwmm->actions.addts.tspec.size,
		   setwmm->actions.addts.tspec.maxsize,
		   setwmm->actions.addts.tspec.min_srvc,
		   setwmm->actions.addts.tspec.max_srvc,
		   setwmm->actions.addts.tspec.inactivity,
		   setwmm->actions.addts.tspec.suspension,
		   setwmm->actions.addts.tspec.srvc_strt_tim,
		   setwmm->actions.addts.tspec.mindatarate,
		   setwmm->actions.addts.tspec.meandatarate,
		   setwmm->actions.addts.tspec.peakdatarate,
		   setwmm->actions.addts.tspec.burstsize,
		   setwmm->actions.addts.tspec.delaybound,
		   setwmm->actions.addts.tspec.PHYrate,
		   setwmm->actions.addts.tspec.sba,
		   setwmm->actions.addts.tspec.medium_time,
		   setwmm->actions.addts.accesscat);

            // you should set your tspec here.

            system(gCmdStr);
        }
        else if (setwmm->action == WMMAC_DELTS)
	{
             // send del tspec
        }

        setwmmResp->status = STATUS_COMPLETE;
        break;

    case GROUP_WMMCONF:
        sprintf(gCmdStr, "iwconfig %s rts %d",
                ifname,setwmm->actions.config.rts_thr);

        system(gCmdStr);
        sprintf(gCmdStr, "iwconfig %s frag %d",
                ifname,setwmm->actions.config.frag_thr);

        system(gCmdStr);
        sprintf(gCmdStr, "iwpriv %s wmmcfg %d",
                ifname, setwmm->actions.config.wmm);

        system(gCmdStr);
        setwmmResp->status = STATUS_COMPLETE;
        break;

    default:
        DPRINT_ERR(WFA_ERR, "The group %d is not supported\n",setwmm->group);
        setwmmResp->status = STATUS_ERROR;
        break;

    }

    wfaEncodeTLV(WFA_STA_SET_WMM_RESP_TLV, 4, (BYTE *)setwmmResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
#endif

    return TRUE;
}

int wfaStaSendNeigReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   //dutCommand_t *sendNeigReq = (dutCommand_t *)caCmdBuf;
   dutCmdResponse_t *sendNeigReqResp = &gGenericResp;

   /*
    *  run your device to send NEIGREQ
    */

   sendNeigReqResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SEND_NEIGREQ_RESP_TLV, 4, (BYTE *)sendNeigReqResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

int wfaStaSetEapFAST(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetEapFAST_t *setFAST= (caStaSetEapFAST_t *)caCmdBuf;
    char *ifname = setFAST->intf;
    dutCmdResponse_t *setEapFastResp = &gGenericResp;

#ifdef WFA_NEW_CLI_FORMAT
    sprintf(gCmdStr, "wfa_set_eapfast %s %s %s %s %s %s", ifname, setFAST->ssid, setFAST->username,
                                                          setFAST->passwd, setFAST->pacFileName,
                                                          setFAST->innerEAP);
    system(gCmdStr);
#else

    sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setFAST->ssid);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setFAST->username);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setFAST->passwd);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap FAST", ifname);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 pac_file '\"%s/%s\"'", ifname, CERTIFICATES_PATH,     setFAST->pacFileName);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 anonymous_identity '\"anonymous\"'", ifname);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase1 '\"fast_provisioning=1\"'", ifname);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase2 '\"auth=%s\"'", ifname,setFAST->innerEAP);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
    system(gCmdStr);
#endif

    setEapFastResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_EAPFAST_RESP_TLV, 4, (BYTE *)setEapFastResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return TRUE;
}

int wfaStaSetEapAKA(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaSetEapAKA_t *setAKA= (caStaSetEapAKA_t *)caCmdBuf;
    char *ifname = setAKA->intf;
    dutCmdResponse_t *setEapAkaResp = &gGenericResp;

#ifdef WFA_NEW_CLI_FORMAT
    sprintf(gCmdStr, "wfa_set_eapaka %s %s %s %s", ifname, setAKA->ssid, setAKA->username, setAKA->passwd);
    system(gCmdStr);
#else

    sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setAKA->ssid);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
    system(gCmdStr);
    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA2", ifname);
    system(gCmdStr);
    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto CCMP", ifname);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap AKA", ifname);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase1 \"result_ind=1\"", ifname);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setAKA->username);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setAKA->passwd);
    system(gCmdStr);

    sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
    system(gCmdStr);
#endif

    setEapAkaResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_EAPAKA_RESP_TLV, 4, (BYTE *)setEapAkaResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

int wfaStaSetSystime(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetSystime_t *systime = (caStaSetSystime_t *)caCmdBuf;
   dutCmdResponse_t *setSystimeResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetSystime ...\n");

   sprintf(gCmdStr, "date %d-%d-%d",systime->month,systime->date,systime->year);
   system(gCmdStr);

   sprintf(gCmdStr, "time %d:%d:%d", systime->hours,systime->minutes,systime->seconds);
   system(gCmdStr);

   setSystimeResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_SYSTIME_RESP_TLV, 4, (BYTE *)setSystimeResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

#ifdef WFA_STA_TB
??
int wfaStaPresetParams(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *PresetParamsResp = &gGenericResp;
   caStaPresetParameters_t *presetParams = (caStaPresetParameters_t *)caCmdBuf;
   //int ret;
   //char *intfname = presetParams->intf;
   BYTE presetDone = 1;
   int st = 0;

   DPRINT_INFO(WFA_OUT, "Inside wfaStaPresetParameters function ...\n");

   if(presetParams->wmmFlag)
   {
      st = wfaExecuteCLI(gCmdStr);
      switch(st)
      {
         case 0:
         presetDone = 1;
         break;
         case 1:
         presetDone = 0;
         break;
         case 2:
         presetDone = 0;
         break;
      }
   }

   if(presetParams->modeFlag != 0)
   {
      switch(presetParams->wirelessMode)
      {
         default:
         printf("other mode does not need to support\n");
      }

      st = wfaExecuteCLI(gCmdStr);
      switch(st)
      {
         case 0:
         presetDone = 1;
         break;
         case 1:
         presetDone = 0;
         case 2:
         presetDone = 0;
         break;
      }
   }


   if(presetParams->psFlag)
   {

      printf("%s\n", gCmdStr);
      system(gCmdStr);
   }

   /************the followings are used for Voice Enterprise **************/
   if(presetParams->ftoa == eEnable)
   {
      // enable Fast BSS Transition Over the Air
   }
   else
   {
      // disable Fast BSS Transition Over the Air

   }

   if(presetParams->ftds == eEnable)
   {
      // enable Fast BSS Transition Over the DS

   }
   else
   {
      // disable Fast BSS Transition Over the DS

   }

   if(presetParams->activescan == eEnable)
   {
      // Enable Active Scan on STA

   }
   else
   {
      // disable Active Scan on STA

   }


   if (presetDone)
   {
      PresetParamsResp->status = STATUS_COMPLETE;
   }
   else
   {
      PresetParamsResp->status = STATUS_INVALID;
   }

   wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)PresetParamsResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}
#endif

int wfaStaSetWireless(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staWirelessResp = &gGenericResp;

    staWirelessResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_WIRELESS_RESP_TLV, 4, (BYTE *)staWirelessResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    return TRUE;
}

int wfaStaSendADDBA(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staSendADDBAResp = &gGenericResp;

    wfaEncodeTLV(WFA_STA_SET_SEND_ADDBA_RESP_TLV, 4, (BYTE *)staSendADDBAResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;
    return TRUE;
}

int wfaStaSetRIFS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
        dutCmdResponse_t *staSetRIFSResp = &gGenericResp;

        wfaEncodeTLV(WFA_STA_SET_RIFS_TEST_RESP_TLV, 4, (BYTE *)staSetRIFSResp, respBuf);
        *respLen = WFA_TLV_HDR_LEN + 4;

        return TRUE;

}

int wfaStaSendCoExistMGMT(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staSendMGMTResp = &gGenericResp;

    wfaEncodeTLV(WFA_STA_SEND_COEXIST_MGMT_RESP_TLV, 4, (BYTE *)staSendMGMTResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return TRUE;

}

int wfaStaResetDefault(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaResetDefault_t *reset = (caStaResetDefault_t *)caCmdBuf;
   dutCmdResponse_t *ResetResp = &gGenericResp;


   // need to make your own command available for this, here is only an example
   sprintf(gCmdStr, "myresetdefault %s program %s", reset->intf, reset->prog);
   system(gCmdStr);

   ResetResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_RESET_DEFAULT_RESP_TLV, 4, (BYTE *)ResetResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

int wfaStaTestBedCmd(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *staCmdResp = &gGenericResp;

    wfaEncodeTLV(WFA_STA_DISCONNECT_RESP_TLV, 4, (BYTE *)staCmdResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    return TRUE;
}


/* Execute CLI, read the status from Environment variable */
int wfaExecuteCLI(char *CLI)
{
   char *retstr;

   system(CLI);

   retstr = getenv("WFA_CLI_STATUS");
   printf("cli status %s\n", retstr);
   return atoi(retstr);
}

/* Supporting Functions */

void wfaSendPing(tgPingStart_t *staPing, float *interval, int streamid)
{
    int totalpkts;
    char cmdStr[256];
//    char *addr = staPing->dipaddr;

#ifdef WFA_PC_CONSOLE
    char addr[20];
    char bflag[] = "-b";
    char *tmpstr;
    int inum=0;
#else
    char bflag[] = "  ";
#endif

    DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);
    system("date");

    totalpkts = staPing->duration * staPing->frameRate;
#ifdef WFA_PC_CONSOLE

    printf("\nCS : The Stream ID is %d",streamid);
    DPRINT_INFO(WFA_OUT, "\nCS :the addr is %s ",addr);
    strcpy(addr,staPing->dipaddr);
    DPRINT_INFO(WFA_OUT, "\nCS :Inside the WFA_PC_CONSLE BLOCK");
    DPRINT_INFO(WFA_OUT, "\nCS :the addr is %s ",addr);
    tmpstr = strtok(addr, ".");

    inum = atoi(tmpstr);

    DPRINT_INFO(WFA_OUT, "interval %f\n", *interval);

    if(inum >= 224 && inum <= 239) // multicast
    {

    }
    else // if not MC, check if it is BC address
    {
    DPRINT_INFO(WFA_OUT, "\nCS :Inside the BC address BLOCK");
    DPRINT_INFO(WFA_OUT, "\nCS :the inum %d",inum);
        strtok(NULL, ".");
        //strtok(NULL, ".");
        tmpstr = strtok(NULL, ".");
        DPRINT_INFO(WFA_OUT, "tmpstr %s\n", tmpstr);
        inum = atoi(tmpstr);
    DPRINT_INFO(WFA_OUT, "\nCS : The string is %s",tmpstr);
        if(inum != 255)
           memset(bflag, 0, strlen(bflag));
    }
#endif

    /* Use the "-S 111616" command line option to set the socket send buffer size.
     * This is the default socket send buffer size; however, the ping utility
     * decreases it unless -S is specified.
     *
     * A large socket send buffer size is required by P2P test cases 6.1.13
     * and 7.1.5.
     */
    printf("\nCS : The Stream ID is %d",streamid);
    sprintf(cmdStr, "echo streamid=%i > %s/spout_%d.txt;%s %s %s -i %f -c %i -s %i -S 111616 -q >> %s/spout_%d.txt 2>/dev/null",
          streamid, NET_FILE_CREATION_PATH, streamid, WFA_PING_SCRIPT, bflag, staPing->dipaddr, *interval, totalpkts, staPing->frameSize, NET_FILE_CREATION_PATH,streamid);
    system(cmdStr);
    DPRINT_INFO(WFA_OUT, "\nCS : The command string is %s",cmdStr);

    sprintf(cmdStr, "%s %s/spout_%d.txt", UPDATE_PID_SCRIPT, NET_FILE_CREATION_PATH, streamid);
    system(cmdStr);
    DPRINT_INFO(WFA_OUT, "\nCS : The command string is %s\n",cmdStr);

}

int wfaStopPing(dutCmdResponse_t *stpResp, int streamid)
{
    char strout[256];
    FILE *tmpfile = NULL;
    char cmdStr[256];
    DPRINT_INFO(WFA_OUT, "Ping stop id %d\n", streamid);
    sprintf(cmdStr, "%s %s/spout_%d.txt %s/pid.txt", GET_PID_SCRIPT, NET_FILE_CREATION_PATH, streamid, NET_FILE_CREATION_PATH);
    system(cmdStr);

    DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);
    DPRINT_INFO(WFA_OUT, "\nCS : The command string is %s",cmdStr);

    sprintf(cmdStr, "%s %s/pid.txt ; sleep 2", STOPING_SCRIPT, NET_FILE_CREATION_PATH);
    DPRINT_INFO(WFA_OUT, "%s\n", cmdStr);
    system(cmdStr);

    sprintf(cmdStr, "%s %s/spout_%d.txt", GET_PSTATS_SCRIPT, NET_FILE_CREATION_PATH, streamid);
    //system("getpstats.sh /tmp/spout_%d.txt");

    system(cmdStr);

    DPRINT_INFO(WFA_OUT, "\nCS : The command string is %s\n",cmdStr);

	sprintf(cmdStr, "%s/stpsta.txt", NET_FILE_CREATION_PATH);
    tmpfile = fopen(cmdStr, "r+");

    if(tmpfile == NULL)
    {
        return FALSE;
    }

    if(fscanf(tmpfile, "%s", strout) != EOF)
    {
        if(*strout == '\0')
        {
            stpResp->cmdru.pingStp.sendCnt = 0;
        }

        else
            stpResp->cmdru.pingStp.sendCnt = atoi(strout);
    }

    DPRINT_INFO(WFA_OUT, "after scan sent count %i\n", stpResp->cmdru.pingStp.sendCnt);


    if(fscanf(tmpfile, "%s", strout) != EOF)
    {
        if(*strout == '\0')
        {
            stpResp->cmdru.pingStp.repliedCnt = 0;
        }
        else
            stpResp->cmdru.pingStp.repliedCnt = atoi(strout);
    }
    DPRINT_INFO(WFA_OUT, "after scan replied count %i\n", stpResp->cmdru.pingStp.repliedCnt);

    fclose(tmpfile);

    return TRUE;
}


/*
 * wfaStaGetP2pDevAddress():
 */
int wfaStaGetP2pDevAddress(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   BCMP2P_ETHER_ADDR dev_addr;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /* Fetch the device ID and store into infoResp->cmdru.devid */

   if (BCMP2PGetDevAddr(p2papp_get_hdl(), &dev_addr) != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_P2P_DEV_ADDRESS_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "BCMP2PGetDevAddr failed\n");
      return FALSE;
   }

   wfa_snprintf(resp->cmdru.devid, sizeof(resp->cmdru.devid),
            "%02x:%02x:%02x:%02x:%02x:%02x",
            dev_addr.octet[0], dev_addr.octet[1], dev_addr.octet[2],
            dev_addr.octet[3], dev_addr.octet[4], dev_addr.octet[5]);

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_GET_P2P_DEV_ADDRESS_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}



/*
 * wfaStaSetP2p():
 */
int wfaStaSetP2p(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   caStaSetP2p_t *set_params = (caStaSetP2p_t *)caCmdBuf;
   BCMP2P_STATUS status = BCMP2P_SUCCESS;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /* Set listen channel. */
   if (set_params->listen_chn_flag)
   {
      DPRINT_INFO(WFA_OUT, "%s: listen_chn=%d\n", __FUNCTION__, set_params->listen_chn);
      status = p2papp_set_listen_channel(set_params->listen_chn);
      if (status != BCMP2P_SUCCESS)
         goto exit;
   }

   /* Set persistent flag. */
   if (set_params->persistent_flag)
   {
      DPRINT_INFO(WFA_OUT, "%s: persistent=%d\n", __FUNCTION__, set_params->persistent);
      p2papp_enable_persistent = set_params->persistent;
      status = BCMP2PEnablePersistent(p2papp_dev_hdl, p2papp_enable_persistent);
      if (status != BCMP2P_SUCCESS)
         goto exit;
   }

   /* Intra-BSS */
   if (set_params->intra_bss_flag)
   {
      DPRINT_INFO(WFA_OUT, "%s: intra_bss=%d\n", __FUNCTION__, set_params->intra_bss );
      status = BCMP2PEnableIntraBss(p2papp_dev_hdl,
      set_params->intra_bss == 0 ? BCMP2P_FALSE : BCMP2P_TRUE);
      if (status != BCMP2P_SUCCESS)
         goto exit;
   }

   /* NoA parameters */
   {
      if (set_params->noa_duration_flag)
      {
      DPRINT_INFO(WFA_OUT, "%s: noa_dur=%d\n", __FUNCTION__, set_params->noa_duration );
         gNoa.isEnabled = BCMP2P_TRUE;
         gNoa.duration = set_params->noa_duration * 1000;
      }

      if (set_params->noa_interval_flag)
      {
      DPRINT_INFO(WFA_OUT, "%s: noa_int=%d\n", __FUNCTION__, set_params->noa_interval );
         gNoa.isEnabled = BCMP2P_TRUE;

         if (set_params->noa_interval == 0)
         {
            /* If NoA Interval is specified as 0 then the STA shall configure the
             * NoA Interval equal to the Beacon Interval. */
            gNoa.interval = 102400;
         }
         else
         {
            gNoa.interval = set_params->noa_interval * 1000;
         }
      }

      if (set_params->noa_count_flag)
      {
      DPRINT_INFO(WFA_OUT, "%s: noa_cnt=%d\n", __FUNCTION__, set_params->noa_count);
         gNoa.isEnabled = BCMP2P_TRUE;
         gNoa.count = set_params->noa_count;
      }



      if (gNoa.isEnabled)
      {
         BCMP2P_NOA_DESC desc;
         BCMP2P_NOA_TYPE type;
         BCMP2P_NOA_ACTION action;
         BCMP2P_NOA_OPTION option;

         gNoa.isEnabled = BCMP2P_FALSE;
         memset(&desc, 0, sizeof(desc));

         if (gNoa.count != BCMP2P_NOA_DESC_CONTINUOUS)
         {
            /* Sigma CAPI spec states: "If NoA count is less than 255 (which
             * implies that it will be non-periodic NoA) then the start offset
             * for NoA shall be configured to be 10 milliseconds or greater
             * after the beacon advertising the NoA."
             *
             * Set the start time to 200msec from now. This should provide
             * a couple beacons to advertise the NoA start-time to clients.
             */
            desc.start = 200 * 1000;
            desc.interval = gNoa.interval;
            desc.duration = gNoa.duration;
            desc.count = gNoa.count;

            type = BCMP2P_NOA_TYPE_REQ_ABS;
            action = BCMP2P_NOA_ACTION_GOOFF;
            option = BCMP2P_NOA_OPTION_TSFOFS;
         }
         else
         {
            /* Continuous NoA interval. */

            /* The P2P test plan specifies NoA durations as a percentage of
             * beacon intervals. However, the Sigma API specifies absolute values
             * in (integral) milliseconds. This makes it impossible to specify
             * the exact beacon interval (102.4 msec). The P2P test scripts
             * should specify an interval value of 0 for the beacon interval;
             * however, some scripts still use a value of 100 to indicate
             * the beacon interval.
             */

            if ((gNoa.interval == 102400) || (gNoa.interval == 100000))
            {
               type = BCMP2P_NOA_TYPE_ABS;
               //action = BCMP2P_NOA_ACTION_DOZE;
               action = BCMP2P_NOA_ACTION_NONE;
               option = BCMP2P_NOA_OPTION_BCNPCT;

               desc.start = 100 - (gNoa.duration / 1000);
               desc.duration = (gNoa.duration / 1000);
            }
            else
            {
               type = BCMP2P_NOA_TYPE_ABS;
               //action = BCMP2P_NOA_ACTION_DOZE;
               action = BCMP2P_NOA_ACTION_NONE;
               option = BCMP2P_NOA_OPTION_NORMAL;

               desc.interval = gNoa.interval;
               desc.duration = gNoa.duration;
               desc.count = gNoa.count;
            }
         }

         status = BCMP2PSetNoaSchedule(p2papp_dev_hdl,
            type, action, option, 1, &desc);
         if (status != BCMP2P_SUCCESS)
         {
            goto exit;
         }
      }
   }

   /* Concurrent */
   if (set_params->concurrency_flag)
   {
      DPRINT_INFO(WFA_OUT, "%s: concurrency=%d\n", __FUNCTION__, set_params->concurrency );
      status = BCMP2PEnableConcurrent(p2papp_dev_hdl,
      set_params->concurrency == 0 ? BCMP2P_FALSE : BCMP2P_TRUE);
      if (status != BCMP2P_SUCCESS)
         goto exit;
   }

   /* Invitation */
   if (set_params->p2p_invitation_flag)
   {
      DPRINT_INFO(WFA_OUT, "%s: invitation=%d\n", __FUNCTION__, set_params->p2p_invitation );
      status = BCMP2PEnableInvitation(p2papp_dev_hdl,
      set_params->p2p_invitation == 0 ? BCMP2P_FALSE : BCMP2P_TRUE);
      if (status != BCMP2P_SUCCESS)
         goto exit;
   }

   /* Set beacon interval */
   if (set_params->bcn_int_flag)
   {
      int bi = set_params->bcn_int;

      DPRINT_INFO(WFA_OUT, "%s: set bi=%d\n", __FUNCTION__, bi);
      status = BCMP2PIoctlSet(p2papp_dev_hdl, WLC_SET_BCNPRD, &bi, sizeof(int));
      if (status != BCMP2P_SUCCESS)
         goto exit;
   }

   /* Set extended listen time parameters */
   {
      static int ext_listen_time_int = 0;
      static int ext_listen_time_period = 0;
      int is_ext_listen_time_changed = BCMP2P_FALSE;

      if (set_params->ext_listen_time_int_flag)
      {
      DPRINT_INFO(WFA_OUT, "%s: ELT_int=%d\n", __FUNCTION__, set_params->ext_listen_time_int);
         ext_listen_time_int = set_params->ext_listen_time_int;
         is_ext_listen_time_changed = BCMP2P_TRUE;
      }

      if (set_params->ext_listen_time_period_flag)
      {
      DPRINT_INFO(WFA_OUT, "%s: ELT_per=%d\n", __FUNCTION__, set_params->ext_listen_time_period);
         ext_listen_time_period = set_params->ext_listen_time_period;
         is_ext_listen_time_changed = BCMP2P_TRUE;
      }

      if (is_ext_listen_time_changed)
      {
         status = BCMP2PExtendedListenTiming(p2papp_dev_hdl, BCMP2P_TRUE,
                                             ext_listen_time_period, ext_listen_time_int);
         if (status != BCMP2P_SUCCESS)
            goto exit;
      }
   }

   /* Client discovery */
   if (set_params->discoverability_flag)
   {
      DPRINT_INFO(WFA_OUT, "%s: discb=%d\n", __FUNCTION__, set_params->discoverability );
      status = BCMP2PEnableClientDiscovery(p2papp_dev_hdl,
      set_params->discoverability == 0 ? BCMP2P_FALSE : BCMP2P_TRUE);
      if (status != BCMP2P_SUCCESS)
         goto exit;
   }

   /* Service discovery */
   if (set_params->service_discovry_flag)
   {
      DPRINT_INFO(WFA_OUT, "%s: servdisc=%d\n", __FUNCTION__, set_params->service_discovery );
      status = BCMP2PEnableServiceDiscovery(p2papp_dev_hdl,
      set_params->service_discovery == 0 ? BCMP2P_FALSE : BCMP2P_TRUE);
      if (status != BCMP2P_SUCCESS)
         goto exit;
   }

	/* GO APSD */
	if (set_params->go_apsd_flag)
	{
		int set = set_params->go_apsd ? 1 : 0;

      	wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl down", WL_BIN_PREFIX_STRING);
      	DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      	system(gCmdStr);

   		wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl wme_apsd %d", WL_BIN_PREFIX_STRING, set);
   		DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
   		system(gCmdStr);

      	wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl up", WL_BIN_PREFIX_STRING);
      	DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      	system(gCmdStr);
	}

   /* Set mode. */
   if (set_params->p2p_mode_flag)
   {
      P2P_MODE mode;
      int rc;

      DPRINT_INFO(WFA_OUT, "%s: p2p_mode=%s\n", __FUNCTION__, set_params->p2p_mode);
      if (strcasecmp("Listen", set_params->p2p_mode) == 0)
      {
         mode = P2P_MODE_LISTEN;
      }
      else if (strcasecmp("Discover", set_params->p2p_mode) == 0)
      {
         mode = P2P_MODE_DISCOVER;
      }
      else if (strcasecmp("Idle", set_params->p2p_mode) == 0)
      {
         mode = P2P_MODE_IDLE;
      }
      else if (strcasecmp("Disable", set_params->p2p_mode) == 0)
      {
         mode = P2P_MODE_DISABLE;
      }
      else
      {
         status = BCMP2P_ERROR;
         goto exit;
      }
      DPRINT_INFO(WFA_OUT, "%s: p2p mode=%s\n", __FUNCTION__, set_params->p2p_mode);

      rc = wfaStaSetP2pMode(mode);
      if (rc == TRUE)
      {
         status = BCMP2P_SUCCESS;
      }
      else
      {
         status = BCMP2P_ERROR;
         goto exit;
      }
   }

exit:
   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_SET_P2P_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
      return FALSE;
   }

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_P2P_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}

/*
 * wfaStaP2pConnect():
 */
int wfaStaP2pConnect(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t  *resp = &gGenericResp;
   caStaP2pConnect_t *getStaP2pConnect = (caStaP2pConnect_t *)caCmdBuf;
   int isClient, goIdx, clientIdx;
   BCMP2P_STATUS     status;
   BCMP2P_WPS_CONFIG_METHODS pd_config_method;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /* This command shall implicitly run the Discovery if the given P2PDeviceID
    * is not already discovered by the STA.
    */

   /* discovery mode */
   if (wfaStaSetP2pMode(P2P_MODE_DISCOVER) == FALSE)
   {
      status = BCMP2P_ERROR;
	  DPRINT_ERR(WFA_ERR, "wfaStaSetP2pMode failed status=%d\n", status);
      goto exit;
   }

   /* Wait to discover peer. */
   status = p2papp_wait_to_discover_peer(getStaP2pConnect->devId,
                                         DISCOVER_PEER_TIMEOUT_SEC, &isClient,
                                         &goIdx, &clientIdx);
   if (status != BCMP2P_SUCCESS)
   {
	  DPRINT_ERR(WFA_ERR, "p2papp_wait_to_discover_peer failed status=%d\n", status);
      goto exit;
   }

   DPRINT_INFO(WFA_OUT, "Peer dev id: %s\n", getStaP2pConnect->devId);

   if (p2papp_enable_wfdisp) {
	   if (!p2papp_wfd_get_disc_entry_availability((const char *)getStaP2pConnect->devId)) {
		  status = BCMP2P_ERROR;
		  DPRINT_ERR(WFA_ERR, "wfaStaP2pConnect failed. status=%d. Peer WFD device session is NOT AVL\n", status);
		  goto exit;
	   }
   }

   DPRINT_INFO(WFA_OUT, "wfaStaP2pConnect continues status=%d. Peer WFD device session is AVL\n", status);

   /* Send provision discovery to the peer with the inverse of our config method. */
   if (g_config_method == BCMP2P_WPS_KEYPAD)
      pd_config_method = BCMP2P_WPS_DISPLAY ;
   else if (g_config_method == BCMP2P_WPS_DISPLAY)
      pd_config_method = BCMP2P_WPS_KEYPAD;
   else if (g_config_method == BCMP2P_WPS_PUSHBUTTON)
      pd_config_method = BCMP2P_WPS_PUSHBUTTON;
   else {
	  DPRINT_ERR(WFA_ERR, "wfaStaP2pConnect failed. Config method 0x%x not allowed."
	 	  "Only display(0x08), pushbutton(0x80), and keypad(0x100) are accepted\n",
		  g_config_method);
	  goto exit;
   }

   status = p2papp_send_provision_discovery(getStaP2pConnect->devId, pd_config_method);
   if (status != BCMP2P_SUCCESS)
   {
	  DPRINT_ERR(WFA_ERR, "p2papp_send_provision_discovery failed status=%d\n", status);
      goto exit;
   }

   /* Connect to group (this is async). */
   status = p2papp_connect(getStaP2pConnect->devId);
   if (status != BCMP2P_SUCCESS)
   {
	  DPRINT_ERR(WFA_ERR, "p2papp_connect failed status=%d\n", status);
      goto exit;
   }

   /* Wait for connection complete. */
   status = p2papp_wait_for_connect_complete(CONNECTION_CREATE_TIMEOUT_MSEC);
   if (status != BCMP2P_SUCCESS)
   {
	  DPRINT_ERR(WFA_ERR, "p2papp_wait_for_connect_complete failed status=%d\n", status);
      goto exit;
   }

exit:
   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_P2P_CONNECT_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
#if EXIT_ON_FAILURE
	  exit(0);
#else
      return FALSE;
#endif
   }

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_CONNECT_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}

static BCMP2P_STATUS setOperatingChannel(BCMP2P_UINT32 channel)
{
	BCMP2P_CHANNEL_CLASS channel_class = BCMP2P_DEFAULT_OP_CHANNEL_CLASS;

	if (channel >= 36 && channel <= 48)
		channel_class = IEEE_5GHZ_20MHZ_CLASS_1;
	else if (channel >= 52 && channel <= 64)
		channel_class = IEEE_5GHZ_20MHZ_CLASS_2_DFS;
	else if (channel >= 149 && channel <= 161)
		channel_class = IEEE_5GHZ_20MHZ_CLASS_3;
	else if (channel >= 100 && channel <= 140)
		channel_class = IEEE_5GHZ_20MHZ_CLASS_4_DFS;


	return BCMP2PSetOperatingChannel(p2papp_dev_hdl,
		channel_class, channel);
}

/*
 * wfaStaStartAutoGo():
 */
int wfaStaStartAutoGo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t   *resp = &gGenericResp;
   caStaStartAutoGo_t *getStaStartAutoGo = (caStaStartAutoGo_t *)caCmdBuf;
   BCMP2P_ETHER_ADDR  dev_addr;
   char               ssid_buf[BCMP2P_MAX_SSID_LEN];
   char               *ssid = NULL;
   BCMP2P_STATUS      status;


   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /* Set the operating channel. */
   status = setOperatingChannel(getStaStartAutoGo->oper_chn);
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }

   /* Generate SSID name. */
   if (getStaStartAutoGo->ssid_flag)
   {
      wfa_snprintf(ssid_buf, sizeof(ssid_buf), "DIRECT-%c%c%s",
               GEN_RAND_P2P_SSID_CHAR, GEN_RAND_P2P_SSID_CHAR,
               getStaStartAutoGo->ssid);

      ssid = ssid_buf;
   }

   /* Create group (async). */
   status = p2papp_create_group(ssid);
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }

   /* Wait for group creation to complete. Timeout 10 sec. */
   status = p2papp_wait_for_group_create_complete(10 * 1000);
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }


   /* Return the Group ID. */
   status = p2papp_get_group_id(&dev_addr, ssid_buf);
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }

   wfa_snprintf(resp->cmdru.grpid, sizeof(resp->cmdru.grpid),
            "%02x:%02x:%02x:%02x:%02x:%02x %s",
            dev_addr.octet[0], dev_addr.octet[1],
            dev_addr.octet[2], dev_addr.octet[3],
            dev_addr.octet[4], dev_addr.octet[5], ssid_buf);


exit:
   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_P2P_START_AUTO_GO_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
      return FALSE;
   }

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_START_AUTO_GO_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}

/*
 * wfaStaWfdp2pSetRtsp(). Obsolete function.
 */
int wfaStaWfdp2pSetRtsp(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   caStaWfdp2pSetRtsp_t *set_params = (caStaWfdp2pSetRtsp_t *)caCmdBuf;
   BCMP2P_STATUS status = BCMP2P_SUCCESS;

   /* Set RTSP session availability */
   if (set_params->sess_avl_flag)
   {
      DPRINT_INFO(WFA_OUT, "%s: sess_avl=%d\n", __FUNCTION__, set_params->sess_avl);
      status = p2papp_wfd_set_rtsp_sess_avl(set_params->sess_avl);
      if (status != BCMP2P_SUCCESS)
         goto exit;
   }

exit:
   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_WFDP2P_SET_RTSP_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
      return FALSE;
   }

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_WFDP2P_SET_RTSP_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}

/*
 * wfaStaP2pStartGrpFormation():
 */
int wfaStaP2pStartGrpFormation(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   caStaP2pStartGrpForm_t *getStaP2pStartGrpForm = (caStaP2pStartGrpForm_t *)caCmdBuf;
   int isClient, goIdx, clientIdx;
   BCMP2P_STATUS status = BCMP2P_SUCCESS;
   int peer_sess_avl;

   DPRINT_INFO(WFA_OUT, "Entering %s ...  init_go_neg=%d\n", __FUNCTION__,
       getStaP2pStartGrpForm->init_go_neg);

   /* Set the intent value. */
   status = BCMP2PSetIntent(p2papp_dev_hdl, getStaP2pStartGrpForm->intent_val);
   if (status != BCMP2P_SUCCESS)
   {
      DPRINT_ERR(WFA_ERR, "BCMP2PSetIntent failed status=%d\n", status);
      goto exit;
   }

   /* Set the operating channel. */
   if (getStaP2pStartGrpForm->oper_chn_flag)
   {
      status = setOperatingChannel(getStaP2pStartGrpForm->oper_chn);
      if (status != BCMP2P_SUCCESS)
      {
      	 DPRINT_ERR(WFA_ERR, "BCMP2PSetOperatingChannel failed status=%d\n", status);
         goto exit;
      }
   }

   /* This command shall implicitly run the Discovery if the given P2PDeviceID
    * is not already discovered by the STA.
    */

   /* discovery mode */
   if (wfaStaSetP2pMode(P2P_MODE_DISCOVER) == FALSE)
   {
      status = BCMP2P_ERROR;
	  DPRINT_ERR(WFA_ERR, "wfaStaSetP2pMode failed status=%d\n", status);
      goto exit;
   }

   /* Wait to discovery peer. */
   status = p2papp_wait_to_discover_peer(getStaP2pStartGrpForm->devId,
                                         DISCOVER_PEER_TIMEOUT_SEC,
                                         &isClient, &goIdx, &clientIdx);
   if (status != BCMP2P_SUCCESS)
   {
      DPRINT_ERR(WFA_ERR, "p2papp_wait_to_discover_peer failed status=%d\n", status);
      goto exit;
   }

   DPRINT_INFO(WFA_OUT, "wfaStaP2pStartGrpFormation: Peer dev id %s\n", getStaP2pStartGrpForm->devId);

   if (p2papp_enable_wfdisp) {
	   if (isClient)
		 peer_sess_avl = p2papp_wfd_get_gc_availability((const char *)getStaP2pStartGrpForm->devId, goIdx);
	   else
		 peer_sess_avl = p2papp_wfd_get_disc_entry_availability((const char *)getStaP2pStartGrpForm->devId);

	   if (!peer_sess_avl) {
		  DPRINT_ERR(WFA_ERR, 
			 "wfaStaP2pStartGrpFormation. Peer WFD device %s session is NOT AVL\n", 
			 (const char *)getStaP2pStartGrpForm->devId);
		  wfa_snprintf(resp->cmdru.grpFormInfo.grpId, sizeof(resp->cmdru.grpFormInfo.grpId), "-1");

		  resp->status = STATUS_SESS_NOA;
		  wfaEncodeTLV(WFA_STA_P2P_START_GRP_FORM_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
		  *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);
		  return (TRUE);
	   }
   }

   DPRINT_INFO(WFA_OUT, "wfaStaP2pStartGrpFormation continues status=%d. Peer WFD device session is AVL\n", status);

   if (getStaP2pStartGrpForm->init_go_neg == 0)
   {
      /* When init_go_neg = 0, the command shall prepare STA to accept GO
       * Negotiation Request and return immediately after that. It should not
       * wait through the end of group formation.
       */


      /* Command return values 'result' and 'groupid' should be NULL. */
      resp->cmdru.grpFormInfo.result[0] = '\0';
      resp->cmdru.grpFormInfo.grpId[0] = '\0';
   }
   else
   {
      if(isClient)
      {
         p2papp_tx_dev_discb_req_to_go(goIdx, clientIdx);

         //p2papp_create_link_to_dev_addr(
         // &p2papp_target_client_addr, p2papp_target_client_channel);

         p2papp_invoke_client_discovery_connection = BCMP2P_TRUE;

		 /* wait for connection attempt - connection is allowed to fail so ignore status */
   		 p2papp_wait_for_connect_complete(CONNECTION_CREATE_TIMEOUT_MSEC);
      }
      else
      {
         BCMP2P_ETHER_ADDR dev_addr;
         char              ssid[BCMP2P_MAX_SSID_LEN + 1];

         /* When init_go_neg = 1, the STA should initiate the GO Negotiation and
          * block through the end of group formation.
          */
         status = p2papp_connect(getStaP2pStartGrpForm->devId);
         if (status != BCMP2P_SUCCESS)
         {
            DPRINT_ERR(WFA_ERR, "p2papp_connect failed status=%d\n", status);
            goto exit;
         }

         status = p2papp_wait_for_connect_complete(CONNECTION_CREATE_TIMEOUT_MSEC);
         if (status == BCMP2P_BOTH_GROUP_OWNER_INTENT ||
             status == BCMP2P_GON_FAILED_INFO_UNAVAIL)
         {
            /* expected and acceptable failures */
            strcpy(resp->cmdru.grpFormInfo.result, "FAIL");
            resp->cmdru.grpFormInfo.grpId[0] = '\0';
            status = BCMP2P_SUCCESS;
            goto exit;
         }
         else if (status != BCMP2P_SUCCESS)
         {
            DPRINT_ERR(WFA_ERR, "p2papp_wait_for_connect_complete failed status=%d\n", status);
            goto exit;
         }

         /* Return the result of GO Negotiation and the Group ID. */
         status = p2papp_get_group_id(&dev_addr, ssid);
         if (status != BCMP2P_SUCCESS)
         {
            DPRINT_ERR(WFA_ERR, "p2papp_get_group_id failed status=%d\n", status);
            goto exit;
         }

         wfa_snprintf(resp->cmdru.grpFormInfo.grpId, sizeof(resp->cmdru.grpFormInfo.grpId),
                  "%02x:%02x:%02x:%02x:%02x:%02x %s",
                  dev_addr.octet[0], dev_addr.octet[1],
                  dev_addr.octet[2], dev_addr.octet[3],
                  dev_addr.octet[4], dev_addr.octet[5], ssid);
      }

      if (BCMP2PIsGroupOwner(p2papp_dev_hdl))
      {
         strcpy(resp->cmdru.grpFormInfo.result, "GO");

      }
      else
      {
         strcpy(resp->cmdru.grpFormInfo.result, "CLIENT");
      }
   }

exit:
   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_P2P_START_GRP_FORM_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
#if EXIT_ON_FAILURE
	  exit(0);
#else
      return FALSE;
#endif
   }

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_START_GRP_FORM_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}


/*
 * wfaStaP2pDissolve():
 */
int wfaStaP2pDissolve(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   BCMP2P_STATUS    status;
   int              rc;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   status = p2papp_disconnect();
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }

   rc = wfaStaSetP2pMode(P2P_MODE_IDLE);
   if (rc != TRUE)
   {
      status = BCMP2P_ERROR;
      goto exit;
   }


exit:
   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_P2P_DISSOLVE_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
      return FALSE;
   }

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_DISSOLVE_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}

/*
 * wfaStaSendP2pInvReq():
 */
int wfaStaSendP2pInvReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t     *resp            = &gGenericResp;
   caStaSendP2pInvReq_t *getStaP2pInvReq = (caStaSendP2pInvReq_t *)caCmdBuf;
   int isClient, goIdx, clientIdx;
   BCMP2P_STATUS        status;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

  /* This command shall implicitly run the Discovery if the given P2PDeviceID
   * is not already discovered by the STA.
   */

   /* discovery mode */
   if (wfaStaSetP2pMode(P2P_MODE_DISCOVER) == FALSE)
   {
      status = BCMP2P_ERROR;
	  DPRINT_ERR(WFA_ERR, "wfaStaSetP2pMode failed status=%d\n", status);
      goto exit;
   }

   /* Wait to discover peer. */
   status = p2papp_wait_to_discover_peer(getStaP2pInvReq->devId,
                                         DISCOVER_PEER_TIMEOUT_SEC, &isClient,
                                         &goIdx, &clientIdx);
   if (status != BCMP2P_SUCCESS)
   {
	  DPRINT_ERR(WFA_ERR, "p2papp_wait_to_discover_peer failed status=%d\n", status);
      goto exit;
   }

   /* Send invite request. */
   status = p2papp_connect(getStaP2pInvReq->devId);
   if (status != BCMP2P_SUCCESS)
   {
		DPRINT_ERR(WFA_ERR, "p2papp_connect failed status=%d\n", status);
		goto exit;
   }

   /* don't wait for STA invite 3rd peer to join GO */
   if (!BCMP2PIsSTA(p2papp_get_hdl()))
   {
   		status = p2papp_wait_for_connect_complete(CONNECTION_CREATE_TIMEOUT_MSEC);
    	if (status != BCMP2P_SUCCESS)
   		{
	  		DPRINT_ERR(WFA_ERR, "p2papp_wait_for_connect_complete failed status=%d\n", status);
      		goto exit;
   		}
   }

exit:
   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_SEND_P2P_INV_REQ_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
#if EXIT_ON_FAILURE
	  exit(0);
#else
      return FALSE;
#endif
   }

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SEND_P2P_INV_REQ_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}


/*
 * wfaStaAcceptP2pInvReq():
 */
int wfaStaAcceptP2pInvReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t       *resp            = &gGenericResp;
   caStaAcceptP2pInvReq_t *getStaP2pInvReq = (caStaAcceptP2pInvReq_t *)caCmdBuf;
   int isClient, goIdx, clientIdx;
   BCMP2P_STATUS          status;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /* This command shall prepare the STA to accept the P2P Invitation Request
   ** and return immediately after that. It should not block waiting for P2P
   ** Invitation Request. */

   /* discovery mode */
   if (wfaStaSetP2pMode(P2P_MODE_DISCOVER) == FALSE)
   {
      status = BCMP2P_ERROR;
	  DPRINT_ERR(WFA_ERR, "wfaStaSetP2pMode failed status=%d\n", status);
      goto exit;
   }

   if (!p2papp_enable_wfdisp) {
	   /* Wait to discover peer. */
	   status = p2papp_wait_to_discover_peer(getStaP2pInvReq->devId,
											 DISCOVER_PEER_TIMEOUT_SEC, &isClient,
											 &goIdx, &clientIdx);
	   if (status != BCMP2P_SUCCESS)
	   {
		  DPRINT_ERR(WFA_ERR, "p2papp_wait_to_discover_peer failed status=%d\n", status);
		  DPRINT_ERR(WFA_ERR, "p2papp_wait_to_discover_peer failed status=%d\n", status);
		  goto exit;
	   }
   }
   else {
	   /* For WFDisp, we need to return immediately */
	   system("sleep 1");
	   status = BCMP2P_SUCCESS;
   }

exit:
   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_ACCEPT_P2P_REQ_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
      return FALSE;
   }

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_ACCEPT_P2P_REQ_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}


/*
 * wfaStaSendP2pProvDisReq():
 */
int wfaStaSendP2pProvDisReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   caStaSendP2pProvDisReq_t *getStaP2pProvDisReq= (caStaSendP2pProvDisReq_t *)caCmdBuf;
   int isClient, goIdx, clientIdx;
   BCMP2P_STATUS status = BCMP2P_SUCCESS;
   BCMP2P_UINT32 configMethods;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /* This command shall implicitly run the Discovery if the given P2PDeviceID
    * is not already discovered by the STA.
    */

   /* discovery mode */
   if (wfaStaSetP2pMode(P2P_MODE_DISCOVER) == FALSE)
   {
      status = BCMP2P_ERROR;
      goto exit;
   }

   /* Wait to discover peer. */
   status = p2papp_wait_to_discover_peer(getStaP2pProvDisReq->devId,
                                         DISCOVER_PEER_TIMEOUT_SEC, &isClient,
                                         &goIdx, &clientIdx);
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }

   if (strcasecmp("Display", getStaP2pProvDisReq->confMethod) == 0)
   {
      configMethods = BCMP2P_WPS_DISPLAY;
   }
   else if (strcasecmp("Label", getStaP2pProvDisReq->confMethod) == 0)
   {
      configMethods = BCMP2P_WPS_LABEL;
   }
   else if (strcasecmp("Keypad", getStaP2pProvDisReq->confMethod) == 0)
   {
      configMethods = BCMP2P_WPS_KEYPAD;
   }
   else
   {
      status = BCMP2P_ERROR;
      if (status != BCMP2P_SUCCESS)
      {
         goto exit;
      }
   }

   status = p2papp_send_provision_discovery(getStaP2pProvDisReq->devId, configMethods);
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }

exit:

   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_SEND_P2P_PROV_DIS_REQ_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
      return FALSE;
   }

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SEND_P2P_PROV_DIS_REQ_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}

/*
 * wfaStaSetWpsPbc():
 */
int wfaStaSetWpsPbc(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   BCMP2P_STATUS    status;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   status = p2papp_clear_gon_waiting();
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }

   status = BCMP2PSelectWpsConfigMethod(p2papp_get_hdl(), BCMP2P_WPS_PUSHBUTTON);
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }

   /* activate pushbutton */
   status = BCMP2PPushButton(p2papp_get_hdl());
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }

exit:
   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_SET_WPS_PBC_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
      return FALSE;
   }

   /* save the config method */
   g_config_method = BCMP2P_WPS_PUSHBUTTON;

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_WPS_PBC_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}

/*
 * wfaStaWpsReadPin():
 */
int wfaStaWpsReadPin(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   BCMP2P_STATUS    status;
   char *pin;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /* Select WPS configuration method. */
   status = BCMP2PSelectWpsConfigMethod(p2papp_get_hdl(), BCMP2P_WPS_DISPLAY);
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }

   pin = p2papp_get_pin();

   /* Return generated PIN. */
   strncpy(resp->cmdru.wpsPin, pin, WFA_WPS_PIN_LEN);

   /* Setting PIN activates WPS */
   BCMP2PSetWPSPin(p2papp_get_hdl(), pin);
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }

exit:
   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_WPS_READ_PIN_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
      return FALSE;
   }

   /* save the config method */
   g_config_method = BCMP2P_WPS_DISPLAY;

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_WPS_READ_PIN_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}


/*
 * wfaStaWpsReadLabel():
 */
int wfaStaWpsReadLabel(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   BCMP2P_STATUS    status;
   char *pin;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /* Temporarily disable this until dynamic changing of PIN is resolved. */

   status = BCMP2PSelectWpsConfigMethod(p2papp_get_hdl(), BCMP2P_WPS_LABEL);
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }

   pin = p2papp_get_pin();

   /* Return generated PIN. */
   strncpy(resp->cmdru.wpsPin, pin, WFA_WPS_PIN_LEN);

   /* Setting PIN activates WPS */
   BCMP2PSetWPSPin(p2papp_get_hdl(), pin);
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }

exit:
   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_WPS_READ_LABEL_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
      return FALSE;
   }

   /* save the config method */
   g_config_method = BCMP2P_WPS_LABEL;

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_WPS_READ_LABEL_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}


/*
 * wfaStaWpsEnterPin():
 */
int wfaStaWpsEnterPin(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t   *resp              = &gGenericResp;
   caStaWpsEnterPin_t *getStaWpsEnterPin = (caStaWpsEnterPin_t *)caCmdBuf;
   BCMP2P_STATUS      status;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   status = BCMP2PSelectWpsConfigMethod(p2papp_get_hdl(), BCMP2P_WPS_KEYPAD);
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }

   /* Set the WPS PIN. */
   status = BCMP2PSetWPSPin(p2papp_get_hdl(), getStaWpsEnterPin->wpsPin);
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }

exit:
   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_WPS_ENTER_PIN_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
      return FALSE;
   }

   /* save the config method */
   g_config_method = BCMP2P_WPS_KEYPAD;

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_WPS_ENTER_PIN_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}


/*
 * wfaStaGetPsk():
 */
int wfaStaGetPsk(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   BCMP2P_UINT8     ssid[32 + 1];
   BCMP2P_UINT8     key[64 + 1];
   BCMP2P_UINT8     passphrase[64 + 1];
   BCMP2P_STATUS    status;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /* Get credentials. */
   status = BCMP2PGetGOCredentials(p2papp_dev_hdl, ssid, key, passphrase);
   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_PSK_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
      return FALSE;
   }


   /* Fill in results. */
   strncpy(resp->cmdru.pskInfo.ssid, (const char *)ssid,
           sizeof(resp->cmdru.pskInfo.ssid));

   strncpy(resp->cmdru.pskInfo.passPhrase, (const char *)passphrase,
           sizeof(resp->cmdru.pskInfo.passPhrase));

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_GET_PSK_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}

/*
 * wfaStaP2pReset():
 */
int wfaStaP2pReset(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   dutCommand_t     *cmd  = (dutCommand_t *)caCmdBuf;
   int              rc;
   BCMP2P_STATUS    status;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   DPRINT_INFO(WFA_OUT, "%s: Calling p2papp_device_reset\n", __FUNCTION__);
   status = p2papp_device_reset();
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }

   rc = wfaStaSetP2pMode(P2P_MODE_IDLE);
   if (rc != TRUE)
   {
      status = BCMP2P_ERROR;
      goto exit;
   }

   /* Remove bogus ARP entries. */
   if (g_bogus_arp_ipaddress[0] != '\0')
   {
      /* Remove static ARP (Address Resolution Protocol) table entry. */
      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "arp -d %s", g_bogus_arp_ipaddress);
      DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      system(gCmdStr);
   }

   /* Remove blocked IP address entries. */
   {
      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "iptables -F");
      DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      system(gCmdStr);
   }


   /* Remove the P2P IE from probe requests and association requests. */
   if (g_p2p_ie_added_to_primary_intf)
   {
      g_p2p_ie_added_to_primary_intf = 0;

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl del_ie %s", WL_BIN_PREFIX_STRING, P2P_VNDR_IE_PARAMS);
      DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      system(gCmdStr);
   }


   /* Reset primary interface.
    */

   /* Disconnect any concurrent connection on the primary interface */
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl disassoc", WL_BIN_PREFIX_STRING);
   DPRINT_INFO(WFA_OUT, "%s: ---wl disassoc\n", __FUNCTION__);
   system(gCmdStr);

   /* Disable power savings. */
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl PM 0", WL_BIN_PREFIX_STRING);
   DPRINT_INFO(WFA_OUT, "%s: ---wl PM 0\n", __FUNCTION__);
   system(gCmdStr);

   /* Disable U-APSD. */
   {
      BCMP2PSetListenInterval(p2papp_dev_hdl, 0);

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl assoc_listen 10", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      system(gCmdStr);

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl down", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      system(gCmdStr);

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl apsta 0", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      system(gCmdStr);

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl ap 0", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      system(gCmdStr);

      BCMP2PStaStoreUAPSD(p2papp_dev_hdl, 0, 0, 0, 0, 0);

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl ap 1", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      system(gCmdStr);

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl apsta 1", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      system(gCmdStr);

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl plcphdr auto", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      system(gCmdStr);

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl up", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
      system(gCmdStr);
   }


   /* Reset 802.11n settings. */
   if (g_reset_11n_settings == TRUE)
   {
      char *ifname = BCMP2PGetNetifName(p2papp_dev_hdl);

      g_reset_11n_settings = FALSE;

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl mimo_bw_cap 2", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl obss_coex 0", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl intol40 0", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl ampdu 1", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl amsdu 0", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl mimo_preamble 0", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl stbc_tx 0", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl stbc_rx 0", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl sgi_tx %d", WL_BIN_PREFIX_STRING, -1);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);

      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl sgi_rx %d", WL_BIN_PREFIX_STRING, 3);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);

      if ((ifname != NULL) && (ifname[0] != '\0')) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl -i %s mimo_ps 3", WL_BIN_PREFIX_STRING, ifname); /* no limit */
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }
   }

   DPRINT_INFO(WFA_OUT, "%s/wl txc_policy 0\n", WL_BIN_PREFIX_STRING);
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl txc_policy 0", WL_BIN_PREFIX_STRING);
   system(gCmdStr);

   /* Allow for long periods of inactivity from associated clients. This is
    * required for some P2P test cases, e.g. 6.1.13 and 7.1.5.
    */
   DPRINT_INFO(WFA_OUT, "%s/wl scb_activity_time 3600\n", WL_BIN_PREFIX_STRING);
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl scb_activity_time 3600", WL_BIN_PREFIX_STRING);
   system(gCmdStr);


   if (!access(IFCONFIG, F_OK))
	   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s %s down 0.0.0.0", IFCONFIG, cmd->intf);
#ifdef IFCONFIG_ALT
   else if (!access(IFCONFIG_ALT, F_OK))
	   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s %s down 0.0.0.0", IFCONFIG_ALT, cmd->intf);
#endif
   else
	   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s %s down 0.0.0.0", IFCONFIG_NOPATH, cmd->intf);

   DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
   system(gCmdStr);

   if (!access(IFCONFIG, F_OK))
	   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s %s up", IFCONFIG, cmd->intf);
#ifdef IFCONFIG_ALT
   else if (!access(IFCONFIG_ALT, F_OK))
	   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s %s up", IFCONFIG_ALT, cmd->intf);
#endif
   else
	   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s %s up", IFCONFIG_NOPATH, cmd->intf);

   DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
   system(gCmdStr);


   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl down", WL_BIN_PREFIX_STRING);
   DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
   system(gCmdStr);
   system("sleep 1");

   /* Turn off A-MPDU for DHCP client interoperability.  This can only be done
    * when wl is down.
    */
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl ampdu 0", WL_BIN_PREFIX_STRING);
   DPRINT_INFO(WFA_OUT, "%s: ---wl ampdu 0\n", __FUNCTION__);
   system(gCmdStr);

   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl up", WL_BIN_PREFIX_STRING);
   DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
   system(gCmdStr);
   system("sleep 1");

   /* Turn off MPC to prevent interfering with packet tx/rx during tests */
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl mpc 0", WL_BIN_PREFIX_STRING);
   DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
   system(gCmdStr);

   /* Delete saved DHCP leases to ensure we get the same dhcpd/dhclient
    * protocol behaviour on each run of any test.
    */
#if DHCP_CLIENT_TYPE_DHCPCD
    wfa_snprintf(gCmdStr, sizeof(gCmdStr), "rm /data/misc/dhcp/dhcpcd-%s.lease", cmd->intf);
#elif DHCP_CLIENT_TYPE_DHCLIENT
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "rm /var/lib/dhclient/dhclient.leases");
#endif
    DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
    system(gCmdStr);

   /* Reset P2Pinterface.
    */
   memset(&gNoa, 0, sizeof(gNoa));


exit:
   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_P2P_RESET_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "p2papp_device_reset failed\n");
      return FALSE;
   }

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_P2P_RESET_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}


/*
 * wfaStaGetP2pIpConfig():
 */
int wfaStaGetP2pIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    int slen, ret, i = 0;
    //caStaGetP2pIpConfig_t *getP2pIpConfig = (caStaGetP2pIpConfig_t *)caCmdBuf;
    dutCmdResponse_t *resp = &gGenericResp;
    caStaGetIpConfigResp_t *ifinfo = &resp->cmdru.getIfconfig;
    int got_ip_addr = 0;
    int retries, max_retries = 60;
    BCMP2P_ETHER_ADDR int_addr;

    FILE *tmpfd = NULL;
    char string[256];
    char *str;
    char *ifname;

    ifname = BCMP2PGetNetifName(p2papp_dev_hdl);
    if ((ifname == NULL) || (ifname[0] == '\0')) {
       DPRINT_ERR(WFA_ERR, "%s: get ifname failed!\n", __FUNCTION__);
       return FALSE;
    }


    DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

    /*
     * check a script file (the current implementation specific)
     */
    ret = access(GET_IP_CONFIG_SCRIPT, F_OK);
    if(ret == -1)
    {
       resp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_GET_P2P_IP_CONFIG_RESP_TLV, 4, (BYTE *)resp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;

       DPRINT_ERR(WFA_ERR, "file not exist\n");
       return FALSE;

    }

    strcpy(ifinfo->dns[0], "0");
    strcpy(ifinfo->dns[1], "0");

    retries = 0;
    while (retries < max_retries)
    {

       /*
        * Run the script file "getipconfig.sh" to check the ip status
        * (current implementation  specific).
        * note: "getipconfig.sh" is only defined for the current implementation
        */
       sprintf(gCmdStr, "%s %s/ipconfig.txt %s %s\n", GET_IP_CONFIG_SCRIPT,
               NET_FILE_CREATION_PATH, ifname, IFCONFIG);
       DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
       system(gCmdStr);

       /* open the output result and scan/retrieve the info */
       sprintf(gCmdStr, "%s/ipconfig.txt", NET_FILE_CREATION_PATH);
       tmpfd = fopen(gCmdStr, "r+");

       if(tmpfd == NULL)
       {
         resp->status = STATUS_ERROR;
         wfaEncodeTLV(WFA_STA_GET_P2P_IP_CONFIG_RESP_TLV, 4, (BYTE *)resp, respBuf);
         *respLen = WFA_TLV_HDR_LEN + 4;

         DPRINT_ERR(WFA_ERR, "file open failed\n");
         return FALSE;
       }

       for(;;)
       {
           if(fgets(string, sizeof(string), tmpfd) == NULL)
              break;

           DPRINT_INFO(WFA_OUT, "%s: %s", __FUNCTION__, string);

           /* check dhcp enabled */
           if(strncmp(string, "dhcpcli", 7) ==0)
           {
               str = strtok(string, "=");
               str = strtok(NULL, "=");
               if(str != NULL)
                  ifinfo->isDhcp = 1;
               else
                  ifinfo->isDhcp = 0;
           }

           /* find out the ip address */
           if(strncmp(string, "ipaddr", 6) == 0)
           {
               str = strtok(string, "=");
               str = strtok(NULL, " ");
               if((str != NULL) && isdigit(str[0]))
               {
                  strncpy(ifinfo->ipaddr, str, 15);
                  ifinfo->ipaddr[15]='\0';
                  got_ip_addr = 1;
                  DPRINT_INFO(WFA_OUT, "%s: Got ipaddr %s\n", __FUNCTION__, ifinfo->ipaddr);
               }
               else
                  strncpy(ifinfo->ipaddr, "none", 15);
           }

           /* check the mask */
           if(strncmp(string, "mask", 4) == 0)
           {
               char ttstr[16];
               char *ttp = ttstr;

               str = strtok_r(string, "=", &ttp);
               if(*ttp != '\0')
               {
                  strcpy(ifinfo->mask, ttp);
                  slen = strlen(ifinfo->mask);
                  ifinfo->mask[slen-1] = '\0';
               }
               else
                  strcpy(ifinfo->mask, "none");

               DPRINT_INFO(WFA_OUT, "%s: Got mask %s\n", __FUNCTION__, ifinfo->mask);
           }

           /* find out the dns server ip address */
           if(strncmp(string, "nameserv", 8) == 0)
           {
               char ttstr[16];
               char *ttp = ttstr;

               str = strtok_r(string, " ", &ttp);
               if(str != NULL && i < 2)
               {
                  strcpy(ifinfo->dns[i], ttp);
                  slen = strlen(ifinfo->dns[i]);
                  ifinfo->dns[i][slen-1] = '\0';
               }
               else
                  strcpy(ifinfo->dns[i], "none");

               i++;
           }
       }

	   fclose(tmpfd);

       if (got_ip_addr)
       {
           break;
       }

       system("sleep 1");
       bcmp2p_event_process(BCMP2P_FALSE);
       retries++;
       DPRINT_INFO(WFA_OUT, "%s: retry %d\n", __FUNCTION__, retries);
    }

    /*
     * Report back the results
     */

    if (got_ip_addr)
    {
       if (BCMP2PGetIntAddr(p2papp_get_hdl(), &int_addr) == BCMP2P_SUCCESS)
       {
          wfa_snprintf(&(ifinfo->mac[0]), sizeof(ifinfo->mac),
                   "%02x:%02x:%02x:%02x:%02x:%02x",
                   int_addr.octet[0], int_addr.octet[1], int_addr.octet[2],
                   int_addr.octet[3], int_addr.octet[4], int_addr.octet[5]);
       }
    }


    if(!got_ip_addr)
    {
        resp->status = STATUS_ERROR;
        wfaEncodeTLV(WFA_STA_GET_P2P_IP_CONFIG_RESP_TLV, 4, (BYTE *)resp, respBuf);
        *respLen = WFA_TLV_HDR_LEN + 4;

        DPRINT_ERR(WFA_ERR, "Failed to get IP address.\n");
#if EXIT_ON_FAILURE
	  exit(0);
#else
      return FALSE;
#endif
    }

    resp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_GET_P2P_IP_CONFIG_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)resp, respBuf);

    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);


    DPRINT_INFO(WFA_OUT, "Exiting %s ...\n", __FUNCTION__);
    return TRUE;
}





/*
 * wfaStaSendServiceDiscoveryReq():
 */
int wfaStaSendServiceDiscoveryReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   caStaSendServiceDiscoveryReq_t *staSendServiceDiscoveryReq= (caStaSendServiceDiscoveryReq_t *)caCmdBuf;
   BCMP2P_STATUS status;
   int isClient, goIdx, clientIdx;

   /* discovery mode */
   if (wfaStaSetP2pMode(P2P_MODE_DISCOVER) == FALSE)
   {
      status = BCMP2P_ERROR;
	  DPRINT_ERR(WFA_ERR, "wfaStaSetP2pMode failed status=%d\n", status);
      goto exit;
   }

   /* Wait to discovery peer. */
   status = p2papp_wait_to_discover_peer(staSendServiceDiscoveryReq->devId,
                                         DISCOVER_PEER_TIMEOUT_SEC,
                                         &isClient, &goIdx, &clientIdx);
   if (status != BCMP2P_SUCCESS)
   {
	  DPRINT_ERR(WFA_ERR, "p2papp_wait_to_discover_peer failed status=%d\n", status);
      goto exit;
   }

   status = p2papp_send_service_discovery_from_name(staSendServiceDiscoveryReq->devId);
   if (status != BCMP2P_SUCCESS)
   {
	  DPRINT_ERR(WFA_ERR, "p2papp_send_service_discovery_from_name failed status=%d\n", status);
      goto exit;
   }

exit:
   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_SEND_SERVICE_DISCOVERY_REQ_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
#if EXIT_ON_FAILURE
	  exit(0);
#else
      return FALSE;
#endif
   }


   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SEND_SERVICE_DISCOVERY_REQ_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}

/*
 * wfaStaSendP2pPresenceReq():
 */
int wfaStaSendP2pPresenceReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   caStaSendP2pPresenceReq_t *staSendP2pPresenceReq= (caStaSendP2pPresenceReq_t *)caCmdBuf;
   BCMP2P_STATUS status = BCMP2P_SUCCESS;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);
   // Implement the function and this does not return any thing back.
   DPRINT_INFO(WFA_OUT, "\n The long long Duration: %lld... ",staSendP2pPresenceReq->duration);
   DPRINT_INFO(WFA_OUT, "\n The long long interval : %lld.. ",staSendP2pPresenceReq->interval);

   status = BCMP2PSendPresenceRequest(p2papp_dev_hdl,
      BCMP2P_TRUE, staSendP2pPresenceReq->duration, staSendP2pPresenceReq->interval,
      BCMP2P_FALSE, 0, 0);
   if (status != BCMP2P_SUCCESS)
   {
      goto exit;
   }

exit:

   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_SEND_P2P_PRESENCE_REQ_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
      return FALSE;
   }

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SEND_P2P_PRESENCE_REQ_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}

/*
 * wfaStaSetSleepReq():
 */
int wfaStaSetSleepReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   caStaSetSleep_t *staSetSleepReq= (caStaSetSleep_t *)caCmdBuf;
   BCMP2P_STATUS status = BCMP2P_SUCCESS;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);


   if (staSetSleepReq->grpId[0] != '\0')
   {
      /* Put P2P interface into power savings mode. */
      status = BCMP2PSetPowerSavingMode(p2papp_dev_hdl, BCMP2P_PS_LEGACY);
   }
   else
   {
      /* Put legacy STA interface into power savings mode. */
      /* Legacy power save - PSPoll. */
      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl PM 1", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);
   }

   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_SET_SLEEP_REQ_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
      return FALSE;
   }

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_SLEEP_REQ_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN +4;

   return TRUE;
}

/*
 * wfaStaSetOpportunisticPsReq():
 */
int wfaStaSetOpportunisticPsReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   caStaSetOpprPs_t *staSetOpperPsReq = (caStaSetOpprPs_t *)caCmdBuf;
   BCMP2P_STATUS status;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   status = BCMP2PEnableOppPwrSave(p2papp_dev_hdl, BCMP2P_TRUE, staSetOpperPsReq->ctwindow);

   if (status != BCMP2P_SUCCESS)
   {
      resp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_SET_OPPORTUNISTIC_PS_REQ_RESP_TLV, sizeof(resp->status),
                   (BYTE *)resp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + sizeof(resp->status);

      DPRINT_ERR(WFA_ERR, "%s failed\n", __FUNCTION__);
      return FALSE;
   }

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_OPPORTUNISTIC_PS_REQ_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

#ifndef WFA_STA_TB
/*
 * wfaStaPresetParams():
 */

int wfaStaPresetParams(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   caStaPresetParameters_t *presetParams = (caStaPresetParameters_t *)caCmdBuf;


   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   if (presetParams->psFlag)
   {
      BYTE ps_mode = presetParams->legacyPowerSave;
      if (ps_mode == 0)
      {
         /* Legacy power save - Off. */
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl PM 0", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }
      else if (ps_mode == 1)
      {
         /* Legacy power save - PSPoll. */
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl PM 1", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }
      else if ((ps_mode == 2) || (ps_mode == 3 ))
      {
         /* Legacy power save - Fast/Non-PSPoll. */
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl PM 2", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }
   }

   // Implement the function and its sub commands
   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

int wfaStaSet11n(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caSta11n_t * v11nParams = (caSta11n_t *)caCmdBuf;
   dutCmdResponse_t *resp = &gGenericResp;
   int bring_down_driver;
   char *ifname;
   int p2p_mode;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /* save current P2P mode and set mode to idle */
   p2p_mode = wfaStaGetP2pMode();
   wfaStaSetP2pMode(P2P_MODE_IDLE);

   g_reset_11n_settings = TRUE;

   /* Some commands require us to bring down the driver. */
   bring_down_driver = 0;
   if ((v11nParams->width[0]       != '\0') ||
       (v11nParams->_40_intolerant != 0xff) ||
       (v11nParams->addba_reject   != 0xff) ||
       (v11nParams->ampdu          != 0xff) ||
       (v11nParams->amsdu          != 0xff) ||
       (v11nParams->greenfield     != 0xff) ||
       (v11nParams->stbc_rx        != 0xffff))
   {
      bring_down_driver = 1;
   }


   /* Driver needs to be down for the following wl commands. */
   if (bring_down_driver)
   {
      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl down", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);
   }
   {
      /* 802.11n Channel Width (20/40/auto). */
      if (!strcmp(v11nParams->width, "20")) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl mimo_bw_cap 0", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }
      else if (!strcmp(v11nParams->width, "40")) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl mimo_bw_cap 1", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }
      else if (!strcmp(v11nParams->width, "auto")) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl mimo_bw_cap 2", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }

      /* 40 Mhz Intolerant. */
      if (v11nParams->_40_intolerant == 1) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl obss_coex 1", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl intol40 1", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }
      else if(v11nParams->_40_intolerant == 0) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl obss_coex 0", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl intol40 0", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }

      /* Reject any ADDBA request by sending ADDBA response with status "decline". */
      if (v11nParams->addba_reject == 1) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl ampdu 0", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }
      else if(v11nParams->addba_reject == 0) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl ampdu 1", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }

      /* AMPDU Aggregation. */
      if (v11nParams->ampdu == 1) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl amsdu 0", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl ampdu 1", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }
      else if(v11nParams->ampdu == 0) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl ampdu 0", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }

      /* AMSDU Aggregation. */
      if (v11nParams->amsdu == 1) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl amsdu 1", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }
      else if(v11nParams->amsdu == 0) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl amsdu 0", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }

      /* HT Greenfield. */
      if (v11nParams->greenfield == 1) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl mimo_preamble 1", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }
      else if(v11nParams->greenfield == 0) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl mimo_preamble 0", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }

      /* STBC Receive Streams. */
      if (v11nParams->stbc_rx == 0) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl stbc_tx 0", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl stbc_rx 0", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }
      else if ((v11nParams->stbc_rx != 0xFFFF) && (v11nParams->stbc_rx > 0)) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl stbc_tx 1", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl stbc_rx 1", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl nrate -m 5 -w 2", WL_BIN_PREFIX_STRING);
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }
   }
   /* Bring the driver back up. */
   if (bring_down_driver)
   {
      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl up", WL_BIN_PREFIX_STRING);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);
   }

   if (v11nParams->mcs_fixedrate[0] != '\0') {
      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl nrate -m %d", WL_BIN_PREFIX_STRING, v11nParams->mcs_fixedrate);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);
   }

   /* Short Guard Interval. */
   if (v11nParams->sgi20 == 1) {
      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl sgi_tx %d", WL_BIN_PREFIX_STRING, -1);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);
      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl sgi_rx %d", WL_BIN_PREFIX_STRING, 3);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);
   }
   else if(v11nParams->sgi20 == 0) {
      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl sgi_tx %d", WL_BIN_PREFIX_STRING, 0);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);
      wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl sgi_rx %d", WL_BIN_PREFIX_STRING, 0);
      DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
      system(gCmdStr);
   }

   /* SM Power Save Mode. */
   ifname = BCMP2PGetNetifName(p2papp_dev_hdl);
   if ((ifname != NULL) && (ifname[0] != '\0')) {
      if (v11nParams->smps == 0) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl -i %s mimo_ps 1", WL_BIN_PREFIX_STRING, ifname); /* dynamic */
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }
      else if(v11nParams->smps == 1) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl -i %s mimo_ps 0", WL_BIN_PREFIX_STRING, ifname); /* static */
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }
      else if(v11nParams->smps == 2) {
         wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl -i %s mimo_ps 3", WL_BIN_PREFIX_STRING, ifname); /* no limit */
         DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
         system(gCmdStr);
      }
   }

   /* restore P2P mode */
   wfaStaSetP2pMode(p2p_mode);

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, 4, (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;
   return TRUE;
}
#endif

int wfaStaDisconnect(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *disc = (dutCommand_t *)caCmdBuf;
   char *intf = disc->intf;
   dutCmdResponse_t *resp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "%s/wl -i %s disassoc", WL_BIN_PREFIX_STRING, intf);
   DPRINT_INFO(WFA_OUT, "%s\n", gCmdStr);
   system(gCmdStr);

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_DISCONNECT_RESP_TLV, 4, (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

    return TRUE;
}

/*
 * wfaStaAddArpTableEntry():
 */
int wfaStaAddArpTableEntry(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   caStaAddARPTableEntry_t *staAddARPTableEntry = (caStaAddARPTableEntry_t *)caCmdBuf;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);


   /* Add static ARP (Address Resolution Protocol) table entry. */
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "arp -s %s %s",
                staAddARPTableEntry->ipaddress, staAddARPTableEntry->macaddress);
   DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
   system(gCmdStr);

   /* Save bogus ARP entry for removal later. */
   strncpy(g_bogus_arp_ipaddress, staAddARPTableEntry->ipaddress, sizeof(g_bogus_arp_ipaddress));

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_ADD_ARP_TABLE_ENTRY_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}

/*
 * wfaStaBlockICMPResponse():
 */
int wfaStaBlockICMPResponse(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *resp = &gGenericResp;
   caStaBlockICMPResponse_t *staBlockICMPResponse = (caStaBlockICMPResponse_t *)caCmdBuf;

   DPRINT_INFO(WFA_OUT, "Entering %s ...\n", __FUNCTION__);

   /* Blocks ICMP responses for the requests coming from the given IP Address. */
   wfa_snprintf(gCmdStr, sizeof(gCmdStr), "iptables -A INPUT -s %s -j DROP",
                staBlockICMPResponse->ipaddress);
   DPRINT_INFO(WFA_OUT, "%s: %s\n", __FUNCTION__, gCmdStr);
   system(gCmdStr);

   resp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_BLOCK_ICMP_RESPONSE_RESP_TLV, sizeof(*resp), (BYTE *)resp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + sizeof(*resp);

   return TRUE;
}



/*
 * wfaStaSetP2pMode():
 */
static int wfaStaSetP2pMode(P2P_MODE mode)
{
   BCMP2P_STATUS status = BCMP2P_ERROR;


   DPRINT_INFO(WFA_OUT, "%s: %d\n", __FUNCTION__, mode);

   if ((mode == P2P_MODE_LISTEN) || (mode == P2P_MODE_DISCOVER))
   {
      if (BCMP2PIsDiscovering(p2papp_dev_hdl))
      {
         status = p2papp_disable_discovery();
         if (status != BCMP2P_SUCCESS)
         {
            return (FALSE);
         }
	  	 p2papp_wait_for_discover_disable(DISCOVERY_DISABLE_MSEC);
      }
      status = p2papp_enable_discovery(mode == P2P_MODE_LISTEN, 0);
   }
   else if (mode == P2P_MODE_IDLE)
   {
      status = p2papp_disable_discovery();
   }
   else if (mode == P2P_MODE_DISABLE)
   {
      status = p2papp_device_reset();
   }

   if (status == BCMP2P_SUCCESS)
   {
        g_p2p_mode = mode;
        return (TRUE);
   }

   return (FALSE);
}

/*
 * wfaStaGetP2pMode():
 */
static int wfaStaGetP2pMode(void)
{
   return (g_p2p_mode);
}

/* Example: wfd_get_parameter,Parameter,rtsp_port */
static int wfaWfdGetParameter(dutCmdParams_t *params)
{
	BOOL ret = FALSE;
	
	if (params == NULL) {
		gGenericResp.status = STATUS_ERROR;
		return FALSE;
	}

	printf("wfaWfdGetParameter: params->parameter %s\n", params->parameter);

	if (strcasecmp(params->parameter, "RtspPort") == 0) {
		/* Get rtsp port of source device, form and set the response string */
		int rtsp_port = p2papp_wfd_get_rtsp_port();
		sprintf(gGenericResp.cmdru.genString, "rtsp_port,%d\n\r", rtsp_port);

		gGenericResp.status = STATUS_COMPLETE;
		ret = TRUE;
	}
	else if (strcasecmp(params->parameter, "TdlsAvl") == 0) {
	  if (strlen(params->peer_p2p_mac) > 0) {
			BCMP2P_BOOL tdls_avl;
			int isClient, goIdx, clientIdx;
			BCMP2P_STATUS status;

			gGenericResp.status = STATUS_COMPLETE;

			/* Enable discovery mode */
			if (wfaStaSetP2pMode(P2P_MODE_DISCOVER) == FALSE) {
			    printf("Failed to set p2p mode to discover\n");
			    goto exit;
			}

			/* Wait to discover peer. */
			status = p2papp_wait_to_discover_peer(params->peer_p2p_mac, DISCOVER_PEER_TIMEOUT_SEC, &isClient, &goIdx, &clientIdx);
			if (status != BCMP2P_SUCCESS) {
			    printf("Failed to discover peer %s\n", params->peer_p2p_mac);
			    goto exit;
			}
			
			tdls_avl = p2papp_wfd_get_peer_tdls_avl(params->peer_p2p_mac);
			sprintf(gGenericResp.cmdru.genString, "tdls,%s\n\r", tdls_avl? "enabled" : "disabled");

			ret = TRUE;
		}
		else {
			/* Missing peer mac for which we want to get its tdls availability */
			printf("wfaWfdGetParameter: Invalid empty peer mac address\n"); 
			gGenericResp.status = STATUS_ERROR;
		}
	}
	else if (strcasecmp(params->parameter, "AltMac") == 0) {
	  /* Get alternative mac */
	  BCMP2P_ETHER_ADDR alt_mac_addr;
	  const char ZERO_MAC[6] = { 0 };

	  gGenericResp.status = STATUS_COMPLETE;
	  ret = TRUE;
	  if (p2papp_wfd_get_alt_mac(params->peer_p2p_mac, &alt_mac_addr)
	      && memcmp(ZERO_MAC, alt_mac_addr.octet, 6) != 0) {
	    sprintf(gGenericResp.cmdru.genString, 
		    "%02x:%02x:%02x:%02x:%02x:%02x\n\r", 
		    alt_mac_addr.octet[0],
		    alt_mac_addr.octet[1],
		    alt_mac_addr.octet[2],
		    alt_mac_addr.octet[3],
		    alt_mac_addr.octet[4],
		    alt_mac_addr.octet[5]);
	  }
	}
	else if (strcasecmp(params->parameter, "HostP2PRole") == 0) {
	  /* Get host p2p role: GC or GO */
	  gGenericResp.status = STATUS_COMPLETE;
	  ret = TRUE;
	  sprintf(gGenericResp.cmdru.genString, "%d\n\r", p2papp_wfd_get_host_p2p_role());
	}
	else {
		/* Unknown parameter */
		gGenericResp.status = STATUS_ERROR;
		
	}

 exit:
	return ret;   
}

/* Example: wfd_set_rtsp,sess_avl,1 */
static int wfaWfdSetRtsp(dutCmdParams_t *params)
{
	/* Set WFD sess availability flag */
	if (params->sess_avl_flag) {
		/* Set sess_avl value */
		if (strcasecmp(params->sess_avl, "1") == 0 ||
			strcasecmp(params->sess_avl, "true") == 0) {
			/* Set rtsp session availability information to p2p */
			p2papp_wfd_set_rtsp_sess_avl(BCMP2P_TRUE);
		}
		else {
			p2papp_wfd_set_rtsp_sess_avl(BCMP2P_FALSE);
		}
	}
	
	/* Set rtsp port number */
	if (params->rtsp_port_flag) {
		p2papp_wfd_set_rtsp_port(params->rtsp_port);
	}

	/* Set hdcp enabled or not */
	if (params->hdcp_flag) {
//		p2papp_wfd_set_hdcp(params->hdcp);
	}

	/* Set device type: source-0 psink-1, 2sink-2 */
	if (params->dev_type_flag) {
	        p2papp_wfd_set_dev_type(atol(params->dev_type));
	}

	/* Set preferred connection type: tdls-1 or p2p-0 */
	if (params->connection_type_flag) {
		p2papp_wfd_set_connection_type(params->connection_type);
	}

	if (strlen(params->alt_mac) > 0)
		p2papp_wfd_set_alt_mac(params->alt_mac);

	gGenericResp.status = STATUS_COMPLETE;
	strcat(gGenericResp.cmdru.genString, "\n\r");

	return TRUE;
}

/* Example: sta_get_parameter,interface,wlan0,Parameter,DiscoveredDevList */
int wfaStaGetParameter(dutCmdParams_t *params) 
{
	printf ("wfaStaGetParameter: parameter %s\n", params->parameter);
 
	if (params->intf[0]) {
		printf ("interface : %s\n", params->intf);
	}
	
	gGenericResp.status = STATUS_COMPLETE;
	if (strcasecmp(params->parameter, "DiscoveredDevList") == 0) {
		/* Get discovered dev list from p2p, form and set the response string */
		BCMP2P_DISCOVER_ENTRY *disc_dev_entries;
		BCMP2P_UINT32 entry_total, i;
		BCMP2P_UINT8 peer_mac[6]; 

		strcpy(gGenericResp.cmdru.genString, "DeviceList,");
		
		/* Get discovered device list and set to response string */
		p2papp_wfd_get_disc_dev_list(&disc_dev_entries, &entry_total);

		for (i = 0; i < entry_total; i++) {
			char dev_addr_str[32];

			if (disc_dev_entries[i].is_p2p_group)
				/* If peer is AutoGO, return its interface address, instead of device addres */
				memcpy(peer_mac, disc_dev_entries[i].int_address, 6);
			else
				memcpy(peer_mac, disc_dev_entries[i].mac_address, 6);
				

			/* Form mac string */
			sprintf(dev_addr_str, "%02x:%02x:%02x:%02x:%02x:%02x",
				peer_mac[0], peer_mac[1], peer_mac[2], peer_mac[3], peer_mac[4], peer_mac[5]);

			sprintf(gGenericResp.cmdru.genString, "%s %s", gGenericResp.cmdru.genString, dev_addr_str);
		}

		/* Example of genString: "DeviceList,00:01:02:03:04:05 22:01:02:03:04:05\n\r" */
		strcat(gGenericResp.cmdru.genString, "\n\r");
	}
	else {
		/* Unknown parameter */
		gGenericResp.status = STATUS_ERROR;
	}
	
	return TRUE;
}

/* 
   match commands with functions and call  

   This is where to add a new cmd name/function pair.
*/
static void wfaGenericExecute(dutCmdParams_t *params, int *respLen, BYTE *respBuf) {

  dutCmdResponse_t *Resp = &gGenericResp;
  char *cmd = params->cmdName;

  printf("wfaGenericExecute: %s\n", cmd);

  if(!strcmp(cmd, "sta_get_parameter")) {
    wfaStaGetParameter(params);
  }
  else if(!strcmp(cmd, "wfd_get_parameter")) {
    wfaWfdGetParameter(params);
  }
  else if(!strcmp(cmd, "wfd_set_rtsp")) {
    wfaWfdSetRtsp(params);
  }
  else {
	  /* Empty or unknown */
	  Resp->status = STATUS_ERROR;
  }
}

/* 
   parse command line, fill up the parameter structure 
   and call the generic execute function.

   Add a case for new name/param pairs.
*/
int WfaGeneric(int len, char *caCmdBuf, int *respLen, BYTE *respBuf) {	
  char *str, *strc;
  char *pcmdStr=caCmdBuf;
  char *cmd;
  dutCmdResponse_t *Resp = &gGenericResp;
  int cmdRespDataLen = 0;
 
  /* Form the cmd string */
  caCmdBuf[len] = 0;

  printf("WfaGeneric: caCmdBuf %s\n", caCmdBuf);

  cmd=strtok_r(NULL, ",", (char **)&pcmdStr);

  if(cmd == NULL) {
    DPRINT_ERR(WFA_ERR, "Invalid command");
    Resp->status = STATUS_ERROR;
    goto send_resp;
  }

  printf("command : %s, command len %d\n", cmd, (int)(strlen(cmd)));

  /* clear previous params */
  memset(&gDutParams, 0, sizeof(gDutParams));

  /* parameters are generic. only their interpretation is dependent
     of the particular command .
     Parse into a global structure.
  */
  /* copy command name  */
  strcpy(gDutParams.cmdName, cmd);

  /* Parse the parameters for the command */
  for(;;) {
      strc = strtok_r(NULL, ",", &pcmdStr);
      printf("parameter : %s\n", strc? strc : "NULL");
      str = strtok_r(NULL, ",", &pcmdStr);  
      printf("value : %s\n", str? str : "NULL");

      if(strc == NULL)
		break;

      if(str && str[0] == '\0')
		break;

      else if(strcasecmp(strc, "interface") == 0)
      {	  
		strncpy(gDutParams.intf, str, 15);
      }
      else if(strcasecmp(strc, "parameter") == 0)
      {
		/* sta_get_parameter,Paramter,DiscoveredDevList */
		strcpy(gDutParams.parameter, str);
      }
      else if(strcasecmp(strc, "sess_avl") == 0)
      {
		gDutParams.sess_avl_flag = 1;
		strcpy(gDutParams.sess_avl, str);
      }
      else if(strcasecmp(strc, "TdlsAvl") == 0)
      {
		/* wfd_get_parameter,TdlsAvl,xx:xx:xx:xx:xx:xx */
		strcpy(gDutParams.parameter, strc);
		if (str)
			strcpy(gDutParams.peer_p2p_mac, str);
      }
      else if(strcasecmp(strc, "RtspPort") == 0)
      {
		if (str) {
			/* Set parameter */
			gDutParams.rtsp_port_flag = 1;
			gDutParams.rtsp_port = atol(str);
		}
		else {
			/* Get parameter: "wfd_get_parameter,RtspPort" */
			strcpy(gDutParams.parameter, strc);
		}
	  }
      else if(strcasecmp(strc, "ConnectionType") == 0)
      {
		/* Preferred connection type */
		if (str) {
			/* This is to set parameter */
			gDutParams.connection_type_flag = 1;
			gDutParams.connection_type = atol(str);
		}
		else {
			/* This is to get parameter */
			strcpy(gDutParams.parameter, strc);
		}
	  }
      else if(strcasecmp(strc, "AltMac") == 0)
      {
		/* Alternative mac */
		if (str) {
			/* Get AltMac parameter value which is the peer p2p device mac */
			strcpy(gDutParams.alt_mac, str);
		}
		else {
			/* Get parameter */
			strcpy(gDutParams.parameter, strc);
		}
	  }
      else if(strcasecmp(strc, "hdcp") == 0)
      {
		if (str) {
			gDutParams.hdcp_flag = 1;
			gDutParams.hdcp = atol(strc);
		}
		else {
			strcpy(gDutParams.parameter, strc);
		}
      }
      else if(strcasecmp(strc, "DeviceType") == 0)
      {
		if (str) {
			gDutParams.dev_type_flag = 1;
			strcpy(gDutParams.dev_type, strc);
		}
		else {
			strcpy(gDutParams.parameter, strc);
		}
      }
      else if(strcasecmp(strc, "HostP2PRole") == 0)
      {
		if (str == NULL)
			strcpy(gDutParams.parameter, strc);
      }
  }

   wfaGenericExecute(&gDutParams, respLen, respBuf);

send_resp:

  /* Create the response TLV */
  cmdRespDataLen = sizeof(gGenericResp.status) + sizeof(gGenericResp.streamId) + strlen(gGenericResp.cmdru.genString);
  wfaEncodeTLV(WFA_STA_GENERIC_CMD_RESP_TLV, cmdRespDataLen, (BYTE*) &gGenericResp, respBuf);
  *respLen = WFA_TLV_HDR_LEN + cmdRespDataLen;

  /* if an nvram value has been set, restart */
  if ( sw_reset ) {
	sw_reset = 0;
	return 1;
  }
  else
	return 0;
}

void WfaReset()
{
	char buf[16];
	/* we should save the command line here, before resetting */
	DPRINT_INFO(WFA_OUT, "rc restart ");
	wfa_snprintf(buf, sizeof(buf), "rc restart");
	system(buf);     	
}

static int wfa_snprintf(char *str, size_t size, const char *format, ...)
{
   va_list argp;
   int     ret;

   va_start(argp, format);
   ret = vsnprintf(str, size, format, argp);
   va_end(argp);

   str[size-1] = '\0';

   return (ret);
}
