/****************************************************************************
 *  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
 *
 *
 *  LICENSE
 *
 *  License is granted only to Wi-Fi Alliance members and designated
 *  contractors (“Authorized Licensees”).N  Authorized Licensees are granted
 *  the non-exclusive, worldwide, limited right to use, copy, import, export
 *  and distribute this software:
 *  (i) solely for noncommercial applications and solely for testing Wi-Fi
 *  equipment; and
 *  (ii) solely for the purpose of embedding the software into Authorized
 *  Licensee’s proprietary equipment and software products for distribution to
 *  its customers under a license with at least the same restrictions as
 *  contained in this License, including, without limitation, the disclaimer of
 *  warranty and limitation of liability, below.N  The distribution rights
 *  granted in clause
 *  (ii), above, include distribution to third party companies who will
 *  redistribute the Authorized Licensee’s product to their customers with or
 *  without such third party’s private label. Other than expressly granted
 *  herein, this License is not transferable or sublicensable, and it does not
 *  extend to and may not be used with non-Wi-Fi applications.N  Wi-Fi Alliance
 *  reserves all rights not expressly granted herein.N
 *N
 *  Except as specifically set forth above, commercial derivative works of
 *  this software or applications that use the Wi-Fi scripts generated by this
 *  software are NOT AUTHORIZED without specific prior written permission from
 *  Wi-Fi Alliance.
 *N
 *  Non-Commercial derivative works of this software for internal use are
 *  authorized and are limited by the same restrictions; provided, however,
 *  that the Authorized Licensee shall provide Wi-Fi Alliance with a copy of
 *  such derivative works under a perpetual, payment-free license to use,
 *  modify, and distribute such derivative works for purposes of testing Wi-Fi
 *  equipment.
 *N
 *  Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 *  or promote products that are derived from or that use this software without
 *  specific prior written permission from Wi-Fi Alliance.
 *
 *  THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR AN PARTICULAR PURPOSE,
 *  ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ******************************************************************************
 */


/*
 * File: wfa_ca.c
 *       This is the main program for Control Agent.
 *
 * Revision History:
 *   2006/06/01 -- BETA Release by qhu
 *   2006/06/13 -- 00.02 Release by qhu
 *   2006/06/30 -- 00.10 Release by qhu
 *   2006/07/10 -- 01.00 Release by qhu
 *   2006/09/01 -- 01.05 Release by qhu
 *   2007/01/11 -- 01.10 released by qhu
 *   2007/02/15 -- WMM beta released by qhu, mkaroshi
 *   2007/03/21 -- 01.40 WPA2 and Official WMM Beta release by qhu
 *   2007/04/20 -- 02.00 WPA2 and Official WMM release by qhu
 *   2007/08/15 --  02.10 WMM-Power Save release by qhu
 *   2007/10/10 --  02.20 Voice SOHO beta -- qhu
 *   2007/11/07 -- 02.30 Voice HSO -- qhu
 *      -- on the calls wfaCtrlSend(), the string len is replaced with strlen()
 *   2007/12/10 -- 02.32 update -- qhu
 *   2008/02/11 -- fix the BUG #5, instead of using done/break (suggested),
 *                 continue is used here.
 */
#include <stdio.h>      /* for printf() and fprintf() */
#include <sys/socket.h> /* for socket(), connect(), send(), and recv() */
#include <arpa/inet.h>  /* for sockaddr_in and inet_addr() */
#include <stdlib.h>     /* for atoi() and exit() */
#include <string.h>     /* for memset() */
#include <unistd.h>     /* for close() */
#include <sys/select.h>
#include <signal.h>

#ifdef TARGETENV_android
#include <pthread.h>
#endif

#include "wfa_debug.h"
#include "wfa_main.h"
#include "wfa_types.h"
#include "wfa_tlv.h"
#include "wfa_tg.h"
#include "wfa_cmds.h"
#include "wfa_miscs.h"
#include "wfa_sock.h"
#include "wfa_ca.h"
#include "wfa_agtctrl.h"
#include "wfa_portall.h"

#define WFA_ENV_AGENT_IPADDR "WFA_ENV_AGENT_IPADDR"

extern int xcCmdProcGeneric(char *pcmdStr, BYTE *aBuf, int *aLen);
extern int wfaStaGenericCmdResp(BYTE *cmdBuf);

extern int xcCmdProcGetVersion(unsigned char *parms);
extern dutCommandRespFuncPtr wfaCmdRespProcFuncTbl[];
extern typeNameStr_t nameStr[];
extern char gRespStr[];

int gSock = -1, tmsockfd, gCaSockfd = -1, xcSockfd, btSockfd;
int gtgSend, gtgRecv, gtgTransac;
char gnetIf[32] = "any";
tgStream_t    *theStreams;
long          itimeout = 0;

unsigned short wfa_defined_debug = WFA_DEBUG_ERR | WFA_DEBUG_WARNING | WFA_DEBUG_INFO;
unsigned short dfd_lvl = WFA_DEBUG_DEFAULT | WFA_DEBUG_ERR | WFA_DEBUG_INFO;

/*
 * Signal handler
 */
static void
signal_hdlr(int sig)
{
   const char *signal_name;
   int exit_app = 1;

   switch (sig)
   {
      case (SIGINT): signal_name = "Ctrl-C"; break;
      case (SIGABRT): signal_name = "Abort"; break;
      case (SIGTERM): signal_name = "Terminate"; break;
      default: signal_name = "default"; break;
   }
   printf("%s: Signal '%s'\n", __FUNCTION__, signal_name);

   if (exit_app)
   {
      wSHUTDOWN(gSock, SHUT_RDWR);
      wSHUTDOWN(tmsockfd, SHUT_RDWR);
      wSHUTDOWN(gCaSockfd, SHUT_RDWR);

      wCLOSE(gSock);
      wCLOSE(tmsockfd);
      wCLOSE(gCaSockfd);
      exit(0);
   }
}


/*
 * the output format can be redefined for file output.
 */

int main(int argc, char *argv[])
{
    int nfds;
    struct sockaddr_in servAddr;
    unsigned short servPort, myport;
    char *servIP=NULL, *tstr=NULL;
    int bytesRcvd;
    fd_set sockSet;
    char cmdName[WFA_BUFF_32];
    int i, isFound = 0, nbytes, tag, ret_status, slen;
    int /*tmsockfd,*/ cmdLen = WFA_BUFF_1K;
    int maxfdn1;
    BYTE xcCmdBuf[WFA_BUFF_4K];
    BYTE caCmdBuf[WFA_BUFF_4K];
    BYTE pcmdBuf[WFA_BUFF_1K];
    char *pcmdStr = NULL;
    char respStr[WFA_BUFF_512];

    signal(SIGINT, signal_hdlr);	/* ctrl-C handler */
    signal(SIGABRT, signal_hdlr);	/* Abort handler */
    signal(SIGTERM, signal_hdlr);	/* Termination handler */


    if(argc < 3)
    {
        DPRINT_ERR(WFA_ERR, "Usage: %s <control interface> <local control agent port>\n", argv[0]);
        exit(1);
    }

    myport = atoi(argv[2]);


    if(argc > 3)
    {
        if(argc < 5)
            {
            DPRINT_ERR(WFA_ERR, "Usage: %s <control interface> <local control agent port> <DUT IP ADDRESS> <DUT PORT>\n", argv[0]);
                exit(1);
            }
        servIP = argv[3];
        if(isIpV4Addr(argv[3])== FALSE)
            return FALSE;
        if(isNumber(argv[4])== FALSE)
           return FALSE;
        servPort = atoi(argv[4]);
        if(argc > 5)
        {
                FILE *logfile;
                int fd;
                logfile = fopen(argv[5],"a");
                if(logfile != NULL)
                {
                        fd = fileno(logfile);
                        DPRINT_INFO(WFA_OUT,"redirecting the output to %s\n",argv[5]);
                        dup2(fd,1);
                        dup2(fd,2);
                }
                else
                {
                        DPRINT_ERR(WFA_ERR, "Cant open the log file continuing without redirecting\n");
                }
        }
    }
    else
    {
        if((tstr = getenv("WFA_ENV_AGENT_IPADDR")) == NULL)
        {
            DPRINT_ERR(WFA_ERR, "Environment variable WFA_ENV_AGENT_IPADDR not set or specify DUT IP/PORT\n");
                exit(1);
        }
        if(isIpV4Addr(tstr)== FALSE)
            return FALSE;
        servIP= tstr;
        if((tstr = getenv("WFA_ENV_AGENT_PORT")) == NULL)
        {
           DPRINT_ERR(WFA_ERR, "Environment variable WFA_ENV_AGENT_PORT not set or specify DUT IP/PORT\n");
           exit(1);
        }
        if(isNumber(tstr)== FALSE)
           return FALSE;
        servPort = atoi(tstr);
    }

    tmsockfd = wfaCreateTCPServSock(myport);

    maxfdn1 = tmsockfd + 1;

    FD_ZERO(&sockSet);
    if(gSock == -1)
    {
        DPRINT_INFO(WFA_OUT, "Create socket port(%d)\n", servPort);
        if ((gSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
        {
            DPRINT_ERR(WFA_ERR, "socket() failed: %i", errno);
            exit(1);
        }

        memset(&servAddr, 0, sizeof(servAddr));
        servAddr.sin_family      = AF_INET;
        servAddr.sin_addr.s_addr = inet_addr(servIP);
        servAddr.sin_port        = htons(servPort);

        if (connect(gSock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
        {
            DPRINT_ERR(WFA_ERR, "connect() failed: %i", errno);
            exit(1);
        }

    }

    for(;;)
    {
        FD_ZERO(&sockSet);
        FD_SET(tmsockfd, &sockSet);
        maxfdn1 = tmsockfd + 1;

        if(gCaSockfd != -1)
        {
            FD_SET(gCaSockfd, &sockSet);
            if(maxfdn1 < gCaSockfd)
                maxfdn1 = gCaSockfd +1;
        }

        if(gSock != -1)
        {
            FD_SET(gSock, &sockSet);
            if(maxfdn1 < gSock)
                maxfdn1 = gSock +1;
        }

        if((nfds = select(maxfdn1, &sockSet, NULL, NULL, NULL)) < 0)
        {
            if(errno == EINTR)
                continue;
            else
                DPRINT_WARNING(WFA_WNG, "select error %i", errno);
        }

        DPRINT_INFO(WFA_OUT, "new event \n");
        if(FD_ISSET(tmsockfd, &sockSet))
        {
            gCaSockfd = wfaAcceptTCPConn(tmsockfd);
            DPRINT_INFO(WFA_OUT, "accept new connection\n");
            continue;
        }

        if(gCaSockfd > 0 && FD_ISSET(gCaSockfd, &sockSet))
        {
            memset(xcCmdBuf, 0, WFA_BUFF_4K);
            memset(gRespStr, 0, WFA_BUFF_512);

            nbytes = wfaCtrlRecv(gCaSockfd, xcCmdBuf);
            if(nbytes <=0)
            {
                wSHUTDOWN(gCaSockfd, SHUT_WR);
                wCLOSE(gCaSockfd);
                gCaSockfd = -1;
                continue;
            }

            /*
             * send back to command line or TM.
             */
            //sleep(1); /* having this is for slowing down unexpected output result on CLI command sometimes */
            memset(respStr, 0, WFA_BUFF_128);
            sprintf(respStr, "status,RUNNING\r\n");
            wfaCtrlSend(gCaSockfd, (BYTE *)respStr, strlen(respStr));

            DPRINT_INFO(WFA_OUT, "%s\n", respStr);
            DPRINT_INFO(WFA_OUT, "message %s %i\n", xcCmdBuf, nbytes);
            slen = (int )strlen((char *)xcCmdBuf);

			if (slen < 3) {
				DPRINT_INFO(WFA_OUT, "empty command.",respStr);
				continue;
			}

            xcCmdBuf[slen-3] = '\0';

            if(gSock == -1)
            {
                DPRINT_INFO(WFA_OUT, "Create socket port(%d)\n", servPort);
                if ((gSock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
                {
                    DPRINT_ERR(WFA_ERR, "socket() failed: %i", errno);
                    exit(1);
                }

                memset(&servAddr, 0, sizeof(servAddr));
                servAddr.sin_family      = AF_INET;
                servAddr.sin_addr.s_addr = inet_addr(servIP);
                servAddr.sin_port        = htons(servPort);

                if (connect(gSock, (struct sockaddr *) &servAddr, sizeof(servAddr)) < 0)
                {
                    DPRINT_ERR(WFA_ERR, "connect() failed: %i", errno);
                    exit(1);
                }
            }

            isFound = 0;

            memcpy(cmdName, strtok_r((char *)xcCmdBuf, ",", (char **)&pcmdStr), 32);
            if (strcmp("ca_quit", cmdName) == 0)
            {
               break;
            }

            i = 0;
            while(nameStr[i].type != -1)
            {
                if(strcmp(nameStr[i].name, cmdName) == 0)
                {
                    isFound = 1;
                    break;
                }
//		printf("Max index: %d",i );
                i++;
            }

	    DPRINT_INFO(WFA_OUT, "At ca. cmdName %s\n", cmdName);
	    memset(pcmdBuf, 0, WFA_BUFF_1K);
            if(isFound == 0)
            {
		DPRINT_INFO(WFA_OUT, "Process generic command %s\n", cmdName);
		printf("pcmdStr %s\n", pcmdStr);

		if (strlen(cmdName) > 0) {
			/* defer to the dut agent to figure it out 
			 * we should not have to maipulate 3 tables to just add a function.
			 */
			isFound = 1;
		
			/* send the command after stripping out the generic cmd to the DUT parser */
			xcCmdBuf[strlen(xcCmdBuf)] = ',';
			xcCmdProcGeneric(xcCmdBuf, pcmdBuf, &cmdLen);
		}
		else {
			sleep(1);
			sprintf(respStr, "status,INVALID\r\n");
			wfaCtrlSend(gCaSockfd, (BYTE *)respStr, strlen(respStr));
			DPRINT_WARNING(WFA_WNG, "Command not valid, It is empty\n");			
			continue;
		}
    	    }
            else if (nameStr[i].cmdProcFunc(pcmdStr, pcmdBuf, &cmdLen)==FALSE)
            {
                sleep(1);
                sprintf(respStr, "status,INVALID\r\n");
                wfaCtrlSend(gCaSockfd, (BYTE *)respStr, strlen(respStr));
                DPRINT_WARNING(WFA_WNG, "Incorrect command syntax\n");
                continue;
            }

            /*
             * send to DUT.
             */
            if(send(gSock, pcmdBuf, cmdLen, 0) != cmdLen)
            {
                DPRINT_WARNING(WFA_WNG, "Incorrect sending ...\n");
                continue;
            }

            DPRINT_INFO(WFA_OUT, "sent to DUT\n");
            //sleep(1);
        } /* done with gCaSockfd */

        if(gSock > 0 && FD_ISSET(gSock, &sockSet))
        {
            DPRINT_INFO(WFA_OUT, "received from DUT\n");
            sleep(1);
            memset(respStr, 0, WFA_BUFF_128);
            memset(caCmdBuf, 0, WFA_BUFF_4K);
            if ((bytesRcvd = recv(gSock, caCmdBuf, WFA_BUFF_4K, 0)) <= 0)
            {
                DPRINT_WARNING(WFA_WNG, "recv() failed or connection closed prematurely");
                continue;
            }

#if DEBUG
            for(i = 0; i< bytesRcvd; i++)
               printf("%x ", caCmdBuf[i]);
               printf("\n");
#endif
            tag = ((wfaTLV *)caCmdBuf)->tag;

            memcpy(&ret_status, caCmdBuf+4, 4);
            DPRINT_INFO(WFA_OUT, "bytes=%i, %i,%i,%x %x %x %x \n", bytesRcvd, ((wfaTLV *)caCmdBuf)->tag,((wfaTLV *)caCmdBuf)->len, *(caCmdBuf+4), *(caCmdBuf+5), *(caCmdBuf+6), *(caCmdBuf+7));


            if((tag != 0 && tag > WFA_STA_NEW_COMMANDS_RESPONSE_START && tag < WFA_STA_NEW_COMMANDS_RESPONSE_END) && wfaCmdRespProcFuncTbl[tag - WFA_STA_NEW_COMMANDS_RESPONSE_START + (WFA_STA_COMMANDS_END -1 )] != NULL)
            {

		DPRINT_INFO(WFA_OUT, "Inside calling function \n");

                wfaCmdRespProcFuncTbl[tag - WFA_STA_NEW_COMMANDS_RESPONSE_START + (WFA_STA_COMMANDS_END -1 )](caCmdBuf);
            }
            else if((tag != 0 && tag < WFA_STA_RESPONSE_END) && wfaCmdRespProcFuncTbl[tag-WFA_STA_COMMANDS_END] != NULL)
            {
                wfaCmdRespProcFuncTbl[tag-WFA_STA_COMMANDS_END](caCmdBuf);
            }
            else
	    {
                DPRINT_WARNING(WFA_WNG, "function not defined. Try to get the generic command response\n");
		wfaStaGenericCmdResp(caCmdBuf);
	    }
        } /* if(gCaSock */

    } /* for */

    wSHUTDOWN(gSock, SHUT_RDWR);
    wSHUTDOWN(tmsockfd, SHUT_RDWR);
    wSHUTDOWN(gCaSockfd, SHUT_RDWR);
    wCLOSE(gSock);
    wCLOSE(tmsockfd);
    wCLOSE(gCaSockfd);
    exit(0);
}
